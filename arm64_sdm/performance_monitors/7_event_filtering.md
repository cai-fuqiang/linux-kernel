The PMU can filter events by various combinations of Exception level and
Security state. This gives software the flexibility to count events across
multiple processes.

## D11.7.1 Filtering by Exception level and Security state

In AArch64 state:
* For each event counter, PMEVTYPER<n>_EL0 specifies the Exception levels in
  which the counter counts events Attributable to Exception levels.
* PMCCFILTR_EL0 specifies the Exception levels in which the cycle counter
  counts. For an event that is Attributable to an Exception level, in a
  multithreaded implementation:
* When the Effective value of PMEVTYPER<n>_EL0.MT is 1, the specified
  filtering is evaluated using the current Exception level and Security state
  of the thread to which the event is Attributable. See Example D11-3.
* When the Effective value of PMEVTYPER<n>_EL0.MT is 0, the event is only
  counted if it is Attributable to the counting thread, and the filtering is
  evaluated using the Exception level and Security state of the counting
  thread.

> Example D11-3 Example of the effect of the PMEVTYPER<n>_EL0.MT control
>
> In a multithreaded implementation, if the Effective value of
> PMEVTYPER<n>_EL0.MT is 1 and the value of

PMEVTYPER<n>_EL0.U is 1 on the counting thread, then event counter n does not
count events Attributable to EL0 on another thread, even if the counting thread
is not executing at EL0.

For each Unattributable event, it is IMPLEMENTATION DEFINED whether the
filtering applies. In a multithreaded implementation, if the filtering applies
to an Unattributable event, then the filtering is evaluated using the Exception
level and Security state of the counting thread.

In AArch32 state, the filtering controls are provided by the PMEVTYPER<n> and
PMCCFILTR registers.

For more information, see the individual register descriptions and
Multithreaded implementations on page D11-5258.

## D11.7.2 Accuracy of event filtering

For most events, it is acceptable that, during a transition between states,
events generated by instructions executed in one state are counted in the other
state. The following sections describe the cases where event counts must not be
counted in the wrong state:

* Exception-related events
* Software increment events on page D11-5261.

### Exception-related events

The PMU must filter events related to exceptions and exception handling
according to the Exception level in which the event occurred. These events are:

* EXC_TAKEN, Exception taken.
* EXC_RETURN, Instruction architecturally executed, Condition code check
  pass, exception return.
* CID_WRITE_RETIRED, Instruction architecturally executed, Condition code
  check pass, write to CONTEXTIDR.
* TTBR_WRITE_RETIRED, Instruction architecturally executed, Condition code
  check pass, write to translation table base.
* EXC_UNDEF, Exception taken, other synchronous.
* EXC_SVC, Exception taken, Supervisor Call.
* EXC_PABORT, Exception taken, Instruction Abort.
* EXC_DABORT, Exception taken, Data Abort or SError.
* EXC_IRQ, Exception taken, IRQ.
* EXC_FIQ, Exception taken, FIQ.
* EXC_SMC, Exception taken, Secure Monitor Call.
* EXC_HVC, Exception taken, Hypervisor Call.
* EXC_TRAP_PABORT, Exception taken, Instruction Abort not Taken locally.
* EXC_TRAP_DABORT, Exception taken, Data Abort or SError not Taken locally.
* EXC_TRAP_OTHER, Exception taken, other traps not Taken locally.
* EXC_TRAP_IRQ, Exception taken, IRQ not Taken locally.
* BRB_FILTRATE, Branch record captured.

The PMU must not count an exception after it has been taken because this could
systematically report a result of zero exceptions at EL0. Similarly, it is not
acceptable for the PMU to count exception returns or writes to CONTEXTIDR after
the return from the exception.

### Software increment events

The PMU must filter software increment events according to the Exception level
in which the software increment occurred. Software increment counting must also
be precise, meaning the PMU must count every architecturally executed software
increment event, and must not count any Speculatively executed software
increment. Software increment events must also be counted without the need for
explicit synchronization. For example, two software increments executed without
an intervening Context synchronization event must increment the event counter
twice.

For more information, see SW_INCR, Instruction architecturally executed,
Condition code check pass, software increment.

### D11.7.3 Pseudocode description of event filtering

See AArch64.CountPMUEvents() and AArch32.CountPMUEvents() in Chapter J1 Armv8
Pseudocode for a pseudocode description of event filtering. However, this
function does not completely describe the behavior for Unattributable events.


