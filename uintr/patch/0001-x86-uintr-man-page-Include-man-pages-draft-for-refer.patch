From d292b8066fb6101c36ab338d5d0a652a05c542ac Mon Sep 17 00:00:00 2001
From: Sohil Mehta <sohil.mehta@intel.com>
Date: Tue, 25 May 2021 16:57:37 -0700
Subject: [PATCH 01/18] x86/uintr/man-page: Include man pages draft for
 reference

draft : 草稿，草案

Included here in plain text format for reference and review.

<Eventually, send the man pages in groff format separately to the
man-pages repository.>

Eventually : 最终
separately : 单独的
repository : 仓库

The formatting for the man pages still needs a little bit of work.

a little bit : 一点点

TODO: The manpages still need to be updated with the latest syscalls.

Signed-off-by: Sohil Mehta <sohil.mehta@intel.com>
---
 tools/uintr/manpages/0_overview.txt           | 290 ++++++++++++++++++
 tools/uintr/manpages/1_register_receiver.txt  | 139 +++++++++
 .../uintr/manpages/2_unregister_receiver.txt  |  62 ++++
 tools/uintr/manpages/3_vector_fd.txt          | 106 +++++++
 tools/uintr/manpages/4_register_sender.txt    | 116 +++++++
 tools/uintr/manpages/5_unregister_sender.txt  |  61 ++++
 tools/uintr/manpages/6_wait.txt               |  64 ++++
 tools/uintr/manpages/7_register_self.txt      |  75 +++++
 tools/uintr/manpages/8_alt_stack.txt          |  63 ++++
 tools/uintr/manpages/9_ipi_fd.txt             |  83 +++++
 10 files changed, 1059 insertions(+)
 create mode 100644 tools/uintr/manpages/0_overview.txt
 create mode 100644 tools/uintr/manpages/1_register_receiver.txt
 create mode 100644 tools/uintr/manpages/2_unregister_receiver.txt
 create mode 100644 tools/uintr/manpages/3_vector_fd.txt
 create mode 100644 tools/uintr/manpages/4_register_sender.txt
 create mode 100644 tools/uintr/manpages/5_unregister_sender.txt
 create mode 100644 tools/uintr/manpages/6_wait.txt
 create mode 100644 tools/uintr/manpages/7_register_self.txt
 create mode 100644 tools/uintr/manpages/8_alt_stack.txt
 create mode 100644 tools/uintr/manpages/9_ipi_fd.txt

diff --git a/tools/uintr/manpages/0_overview.txt b/tools/uintr/manpages/0_overview.txt
new file mode 100644
index 000000000000..28b77fdbbf83
--- /dev/null
+++ b/tools/uintr/manpages/0_overview.txt
@@ -0,0 +1,290 @@
+UINTR(7)               Miscellaneous Information Manual               UINTR(7)
+
+
+
+NAME
+       Uintr - overview of User Interrupts
+
+DESCRIPTION
+       User Interrupts (Uintr) provides a low latency event delivery and inter
+       process communication mechanism. These events can be delivered directly
+       to userspace without a transition to the kernel.
	
	uintr 提供了一个递延迟的event delivery 和进程间通信的机制。这些事件可以在
	不经由kernel的情况下直接delivery到用户态

+
+       In  the  User  Interrupts  hardware  architecture, a receiver is always
+       expected to be a user space task. However, a user interrupt can be sent
+       by  another  user  space  task,  kernel  or  an external source (like a
+       device). The feature that allows another  userspace  task  to  send  an
+       interrupt is referred to as User IPI.
	
	在uintr hardware architecture中, receiver 总是被期望为 userspace task。
	然而，user interrupt 可以被另一个 user space task, kernel 或者
	external source (例如device) 发送。允许另一个userspace task 发送 interrupt 
	的feature 成为 User IPI.

+
+       Uintr  is  a  hardware  dependent,  opt-in  feature. Application aren't
+       expected or able to send or receive  interrupts  unless  they  register
+       themselves with the kernel using the syscall interface described below.
+       It is recommended that applications wanting to use User Interrupts call
+       uintr_register_handler(2) and test whether the call succeeds.
+
	
	Uintr 是一个依赖硬件的，可选择的feature。除非应用程序使用下面描述的syscall 
	interface 向内核注册自己, 否则，它不应该或无法 send/receive interrupts。

+       Hardware  support  for  User  interrupts  may  be  detected using other
+       mechanisms but that could be misleading and is generally not needed:
+        - Using the cpuid instruction (Refer  the  Intel  Software  Developers
+       Manual).
+        -  Checking  for the "uintr" string in /proc/cpuinfo under the "flags"
+       field.

	misleading :误导

	可以使用其他的一些机制来检测 uintr 的硬件支持,但是这可能会产生误导，
	并且通常不需要
	- 使用cpuid instruction (见 SDM)
	- 在 /proc/cpuinfo 中的flags字段，检测 "uintr" string
+
+
+       Applications wanting to use Uintr  should  also  be  able  to  function
+       without  it  as well. Uintr support might be unavailable because of any
+       one of the following reasons:
+        - the kernel code does not contain support
+        - the kernel support has been disabled
+        - the hardware does not support it

	想要使用uintr的应用程序，也应该能够在没有它的情况下运行。Uintr
	support 可能由于下面的一些原因 不被支持:
	- kernel code 没有包含这个支持
	- kernel support 被disabled
	- hardware 不支持
+
+
+   Uintr syscall interface
+       Applications can use and manage Uintr using the system calls  described
+       here.   The  Uintr  system  calls  are  available only if the kernel is
+       configured with the CONFIG_X86_USER_INTERRUPTS option.
	Application 可以通过这里描述的system calls 来使用并且管理 Uintr。Uintr system
	call 只有在kernel 配置了 CONFIG_X86_USER_INTERRUPTS option 的情况下才 available。

+
+       1)  A  user  application   registers   an   interrupt   handler   using
+       uintr_register_handler(2).  The  registered  interrupt  handler will be
+       invoked when a user interrupt is delivered to  that  thread.  Only  one
+       interrupt  handler  can  be  registered by a particular thread within a
+       process.

	1) 用户程序使用 `uintr_register_handler` 来注册 interrupt handler。这个注册的
	interrupt handler 将在 user interrupt delivery 到 该thread时候，被调用。
	进程中的一个特定的线程只能注册一个 interrupt handler。

+
+       2) Each thread that registers a handler has its own unique vector space
+       of 64 vectors. The thread can then use uintr_vector_fd(2) to register a
+       vector and create a user interrupt file descriptor - uvec_fd.
	
	2) 每个thread 可以注册一个handler，该 handler 有自己单独的 64
	vectors中的 vector space。进程可以使用`uintr_vector_fd`来注册一个vector, 并且 
	创建一个 user interrupt fd - uvec_fd.

	NOTE:
	这里 unique 可能是指与众不同的意思。例如，A进程可以注册, 2 3vector, 
	B进程可以注册 4 5 vector, 但是一个thread只能注册一个handler,
	这个handler负责处理该进程注册的所有的vector。
	
+
+       3a) The uvec_fd is only associated with only one Uintr vector.   A  new
+       uvec_fd  must  be  created  for  each  of  the  64  vectors. uvec_fd is
+       automatically inherited by forked processes but the receiver  can  also
+       share  the  uvec_fd with potential senders using any of the existing FD
+       sharing mechanisms (like pidfd_getfd(2) or socket  sendmsg(2)).  Access
+       to uvec_fd allows a sender to generate an interrupt with the associated
+       vector. Upon interrupt delivery, the interrupt handler is invoked  with
+       the  vector  number pushed onto the stack to identify the source of the
+       interrupt.

	uvec_fd 只和一个Uintr vector相关联。必须为 64vectors中的每个vector创建一
	个新的uvec_fd ??? uvec_fd将在 fork 时被自动继承，但是receiver可以通过 任意
	现有的 existing FD sharing mechanism ( pidfd_getfd()/socketsendmeg)向潜在的
	senders共享 uvec_fd

+
+       4) Each thread has a local flag called User Interrupt flag  (UIF).  The
+       thread  can set or clear this flag to enable or disable interrupts. The
+       default value of UIF is always 0 (Interrupts disabled). A receiver must
+       execute  the  _stui()  intrinsic  instruction  at some point (before or
+       anytime after registration) to  start  receiving  user  interrupts.  To
+       disable  interrupts  during  critical  sections the thread can call the
+       _clui() instruction to clear UIF.

	intrinsic: 内部的

	每个thread 有一个称为 User Iuterrupt flags 的local flags . 该thread可以设置/
	清空该flags来 enable/disable interrupts。UIF默认值为0(interrupt disabled)。
	receiver 必须在某些时刻(注册前或者注册后的任何时间)执行 _stui() 内部指令来
	开始接收 user interrupts. 当在critical sections thread可以执行_clui()指令
	clear UIF

+
+       5a) For sending a user IPI, the sender task registers with  the  kernel
+       using  uintr_register_sender(2).  The  kernel  would  setup the routing
+       tables to connect the sender and receiver. The syscall returns an index
+       that can be used with the 'SENDUIPI <index>' instruction to send a user
+       IPI.  If the receiver is running, the interrupt is  delivered  directly
+       to  the  receiver  without  any  kernel  intervention.  See  9) for the
+       behavior when the receiver is not running.

	intervention : 介入

	对于sending 一个 user IPI , sender task 通过uintr_register_sender 向 kernel
	注册。kernel 应该初始化 routing table 来连接 sender 和 receiver。syscall
	返回一个index, 来用作 `SENDUIPI <index>` instruction 指令使用来发送 一个 user 
	IPI。如果receiver 是 running的， interrupt 将被直接delivery 到 recevier, 并且没有
	任何kernel的介入. 请见 9) 来了解 当 receiver 不在 running 时的行为。

+
+       5b) If the sender is the kernel or an external source, the uvec_fd  can
+       be  passed  onto the related kernel entity to allow them to connect and
+       generate the user interrupt. The specifics of this mechanism  would  be
+       defined by the kernel entity being connected to.

	entity : 实体

	如果sender 时kernel 或者是 external source, uvec_fd可以被传递到相应的
	kernel entity 来允许他们去connect 和生成 user interrupt。这个机制的 
	specifics 应该由 将要连接的  kernel entity 定义
+
+       6)  If  a  sender task is part of the same process as the receiver then
+       the FD based connection setup can  be  avoided.  uintr_register_self(2)
+       takes  the  vector  as  an  input  and returns an uipi_index similar to
+       uintr_register_sender(2), which can be used by all tasks  of  the  same
+       process to generate User IPIs.
+
	
	如果一个 sender task 和 receiver 是相同的process, 然后 可以避免执行FD 
	base connection setup  流程. `uintr_register_self` 用vector 作为输入，
	并且返回和`uintr_register_sender`相似的 uipi_index, 他可以被 same process 
	的所有的tasks 生成User IPIs。

+       7) If a sender process wants to share it's IPI connections with another
+       process it can request an IPI FD using uintr_ipi_fd(2). Also,  all  IPI
+       connections are inherited upon fork().

	如果一个sender process 想要去share 他的 IPI co 到另一个process, 它可以使用
	`uintr_ipi_fd`请求一个IPI FD。另外，所有的IPI connections，都可以被fork()继承

+
+       8) The sender and receiver are expected to coordinate and then call the
+       teardown syscalls to terminate the connection:
+         a. A sender unregisters with uintr_unregister_sender(2)
+         b. A receiver unregisters with uintr_unregister_handler(2)
+         c. Calling close() on the file descrpiptors if they have been created
+
	coordinate : 协调
	teardown : 拆卸，卸载

	sender 和 receiver 应进行协调, 然后调用 teardown系统调用来终止连接: 
	  a. sender 通过 uintr_unregister_sender 注销
	  b. receiver 通过 uintr_unresiter_handler 注销
	  c. 如果fd被创建，调用 close()  关闭fd

+       If the sender and receiver  aren't  able  to  coordinate,  some  shared
+       kernel  resources  between  them  would  get  freed later when the file
+       descriptors get released automatically on process exit.

	如果 sender 和 receiver 并没有协调好，某些在他们之中的shared kernel  resources 
	将被freed later(在 process exit 是，被自动的释放)

+
+       9) User Interrupts can only be  delivered  if  a  task  is  running  in
+       ring-3.   The  behavior differs when a receiver is not actively running
+       based on each of the below states.
+

	9) Uintr 只能在 task 运行在 ring-3时，被delivery。当receiver不是
	actively running, 行为会根据下面的状态有所不同。

+       a) The receiver has been context switched out because it's  time  slice
+       has  expired  or  a higher priority task is running. The a pending User
+       Interrupt in that case would be delivered when the receiver is  context
+       switched back.

	a) receiver 
	由于时间片过期，或者是更高优先级的task 正在运行, 已经被 context switched out.
	在这种情况下 pending 的user interrupt  将会在 receiver context switched back 
	时候被 delivery

+
+       b)  The  receiver is in context but not running in ring 3 (probably due
+       to a syscall). The interrupt will be delivered the task  enters  ring-3
+       again.
	
	b)  receiver in context 但是，没有 运行在 ring 3（可能由于syscall)。interrupt
	将再次进入ring-3 重新被delivery

+
+       c)  The  receiver is blocked in the kernel and context switched out due
+       to a blocking system call like read() or  sleep().   The  receiver  can
+       choose  to  be  context  switched  in  and  the  blocking syscall to be
+       interrupted with the -EINTR error code similar to signal().  A specific
+       interrupt handler flag needs to be passed to request such behavior.

	c) receiver 在kernel 中 被 blocked, 并且 由于像 read()/sleep()
	登 blocking systemcall 而context switched out。receiver 可以选择
	context switched in 并且让 该blocking syscall 来被 带有-EINTR error
	code 打断，像 signal()一样。

+
+       The  receiver  can  also  block  in  the kernel using the uintr_wait(2)
+       system call if it is explicitly waiting for user interrupts.

	receiver 也可以使用 uintr_wait(2) syscall block 在 kernel, 如果想显示的
	等待 user interrupt

+
+       10)An process can use uintr_alt_stack(2) if  it  wants  to  handle  the
+       interrupt  on  a  different  stack than the one it was running when the
+       interrupt was received.

	10) 如果想要在另一个不同的stack上处理interrupt, 程序可以使用
	`uintr_alt_stack()`, 否则，将在interrupt收到时运行的堆栈上处理。

+
+
+       Multi-threaded applications need to be careful when using  Uintr  since
+       some  of  the features are thread specific. Actions by one thread might
+       not reflect on other threads of the same application.

	多线程的应用程序在使用uintr 时应该谨慎一些, 因为某些feature 是 thread 
	specific。一个线程的一些动作将不会在 same application 的另一个线程中
	reflect(生效)

+
+
+   Toolchain support
+       Support has added to GCC(11.1)  and  Binutils(2.36.1)  to  enable  user
+       interrupt intrinsic instructions and compiler flag (-muintr).

	在GCC(11.1) 和 

+
+       The "(interrupt)" attribute can be used to compile a function as a user
+       interrupt handler. In conjunction with the 'muintr' flag, the  compiler
+       would:
+         -  Generate  the  entry  and  exit  sequences  for the User interrupt
+       handler
+         - Handle the saving and restoring of registers
+         - Call uiret to return from a user interrupt handler
+
+       User   Interrupts   related   compiler   intrinsic    instructions    -
+       <x86gprintrin.h>:
+
+       _clui() - Disable user interrupts - clear UIF (User Interrupt Flag).
+
+       _stui() - enable user interrupts - set UIF.
+
+       _testui() - test current value of UIF.
+
+       _uiret() - return from a user interrupt handler.
+
+       _senduipi  <uipi_index>  -  send  a  user  IPI  to  a  target task. The
+       uipi_index is obtained using uintr_register_sender(2).
+
+
+   Interrupt handler restrictions
+       There are restrictions on what can be done in a user interrupt handler.
+
+       For example, the handler and the  functions  called  from  the  handler
+       should only use general purpose registers.
+
+       For    details    refer   the   Uintr   compiler   programming   guide.
+       https://github.com/intel/uintr-compiler-guide/blob/uintr-
+       gcc-11.1/UINTR-compiler-guide.pdf
+
+
+CONFORMING TO
+              Uintr related system calls are Linux specific.
+
+EXAMPLES
+   Build
+       To compile this sample an updated toolchain is needed.
+        - Use GCC release 11 or higher &
+        - Use Binutils release 2.36 or higher
+
+       gcc -muintr -mgeneral-regs-only -minline-all-stringops uipi_sample.c -lpthread -o uipi_sample
+
+
+   Run
+       $./uipi_sample
+       Receiver enabled interrupts
+       Sending IPI from sender thread
+            -- User Interrupt handler --
+       Success
+
+
+   Program source
+       #define _GNU_SOURCE
+       #include <pthread.h>
+       #include <stdio.h>
+       #include <stdlib.h>
+       #include <syscall.h>
+       #include <unistd.h>
+       #include <x86gprintrin.h>
+
+       #define __NR_uintr_register_handler     471
+       #define __NR_uintr_unregister_handler   472
+       #define __NR_uintr_vector_fd       473
+       #define __NR_uintr_register_sender 474
+       #define __NR_uintr_unregister_sender    475
+
+       #define uintr_register_handler(handler, flags)    syscall(__NR_uintr_register_handler, handler, flags)
+       #define uintr_unregister_handler(flags)      syscall(__NR_uintr_unregister_handler, flags)
+       #define uintr_vector_fd(vector, flags)       syscall(__NR_uintr_vector_fd, vector, flags)
+       #define uintr_register_sender(fd, flags)     syscall(__NR_uintr_register_sender, fd, flags)
+       #define uintr_unregister_sender(ipi_idx, flags)   syscall(__NR_uintr_unregister_sender, ipi_idx, flags)
+
+       unsigned int uintr_received;
+       unsigned int uvec_fd;
+
+       void __attribute__ ((interrupt)) uintr_handler(struct __uintr_frame *ui_frame,
+                                    unsigned long long vector)
+       {
+            static const char print[] = "\t-- User Interrupt handler --\n";
+
+            write(STDOUT_FILENO, print, sizeof(print) - 1);
+            uintr_received = 1;
+       }
+
+       void *sender_thread(void *arg)
+       {
+            int uipi_index;
+
+            uipi_index = uintr_register_sender(uvec_fd, 0);
+            if (uipi_index < 0) {
+                 printf("Sender register error\n");
+                 exit(EXIT_FAILURE);
+            }
+
+            printf("Sending IPI from sender thread\n");
+            _senduipi(uipi_index);
+
+            uintr_unregister_sender(uipi_index, 0);
+
+            return NULL;
+       }
+
+       int main(int argc, char *argv[])
+       {
+            pthread_t pt;
+
+            if (uintr_register_handler(uintr_handler, 0)) {
+                 printf("Interrupt handler register error\n");
+                 exit(EXIT_FAILURE);
+            }
+
+            uvec_fd = uintr_vector_fd(0, 0);
+            if (uvec_fd < 0) {
+                 printf("Interrupt vector registration error\n");
+                 exit(EXIT_FAILURE);
+            }
+
+            _stui();
+            printf("Receiver enabled interrupts\n");
+
+            if (pthread_create(&pt, NULL, &sender_thread, NULL)) {
+                 printf("Error creating sender thread\n");
+                 exit(EXIT_FAILURE);
+            }
+
+            /* Do some other work */
+            while (!uintr_received)
+                 usleep(1);
+
+            pthread_join(pt, NULL);
+            close(uvec_fd);
+            uintr_unregister_handler(0);
+
+            printf("Success\n");
+            exit(EXIT_SUCCESS);
+       }
+
+
+NOTES
+       Currently, there is no glibc wrapper for the Uintr related system call;
+       call  the system calls using syscall(2).
+
+
+
+                                                                      UINTR(7)
diff --git a/tools/uintr/manpages/1_register_receiver.txt b/tools/uintr/manpages/1_register_receiver.txt
new file mode 100644
index 000000000000..38a80e4d8799
--- /dev/null
+++ b/tools/uintr/manpages/1_register_receiver.txt
@@ -0,0 +1,139 @@
+uintr_register_handler(2)     System Calls Manual    uintr_register_handler(2)
+
+
+
+NAME
+       uintr_register_handler - register a user interrupt handler
+
+
+SYNOPSIS
+        int uintr_register_handler(u64 handler_address, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_register_handler()  registers  a  user  interrupt handler for the
+       calling process. In case of multi-threaded processes the user interrupt
+       handler is only registered for the thread that makes this system call.
+
+       The  handler_address  is  the  function  that would be invoked when the
+       process receives a user interrupt. The function should  be  defined  as
+       below:
+
+       void __attribute__ ((interrupt)) ui_handler(struct __uintr_frame *frame,
+                                                   unsigned long long vector)
+
+       For  more  details  and  an  example  for  the handler definition refer
+       uintr(7).
+
+       Providing an invalid handler_address could lead to  undefined  behavior
+       for the process.
+
+       Each  user  thread can register only one interrupt handler. Each thread
+       that would like to be a receiver must register once.  The  registration
+       is not inherited across forks(2) or when additional threads are created
+       within the same process.
+
+       Each thread within a process gets its own interrupt vector space for 64
+       vectors.  The  vector  number  is  pushed  onto  the  stack when a user
+       interrupt is delivered. Since the  vector  space  is  per-thread,  each
+       receiver can receive up to 64 unique interrupt events.
+
+       For  information  on  creating uvec_fd to register and manage interrupt
+       vectors, refer uintr_vector_fd(2) system call.
+
+       Once an interrupt handler is registered it cannot be changed before the
+       handler   is   unregistered  via  uintr_unregister_handler(2).  Calling
+       uintr_unregister_handler(2)  would  however  invalidate   the   current
+       interrupt resources registered with the kernel.
+
+       The  interrupt  handler gets invoked only while the process is running.
+       If the process is scheduled out or blocked in  the  kernel,  interrupts
+       will be delivered when the process is scheduled again.
+
+       An  experimental  mechanism  to  unblock  a  process  as soon as a user
+       interrupt is detected is available for testing.
+
+       The following flags may be used to  change  the  blocking  behavior  of
+       uintr_register_handler():
+
+       UINTR_HANDLER_FLAG_WAITING_ANY      Enable the support for interrupting
+       blocking system calls. Use any of      the below mechanisms  to  enable
+       support.
+
+       UINTR_HANDLER_FLAG_WAITING_RECEIVER        Enable   the   support   for
+       interrupting blocking system  calls.  The  cost  to       wake  up  the
+       blocking task is paid on the receiver side.
+
+       UINTR_HANDLER_FLAG_WAITING_SENDER         Enable    the   support   for
+       interrupting blocking system  calls.  The  cost  to       wake  up  the
+       blocking task is paid on the sender side.
+
+       UINTR_HANDLER_FLAG_WAITING_NONE        Do   not   enable   interrupting
+       blocking system calls. Set by default unless      any of the above have
+       been specified.
+
+
+   Interrupt handler restrictions
+       There are restrictions on what can be done in a user interrupt handler.
+
+       For  example,  the  handler  and  the functions called from the handler
+       should only use general purpose registers.
+
+       For   details   refer   the   Uintr   compiler    programming    guide.
+       https://github.com/intel/uintr-compiler-guide/blob/uintr-
+       gcc-11.1/UINTR-compiler-guide.pdf
+
+
+   Security implications
+       A lot of security issues that are applicable to signal  handlers,  also
+       apply to user interrupt handlers.
+
+       The  user  interrupt  handler  by-itself  need  not be re-entrant since
+       interrupts are automatically disabled when the handler is invoked.  But
+       this  isn't  valid if the handler is shared between multiple threads or
+       nested interrupts have been enabled.
+
+       Similar to signal handlers, the functions that are called from  a  user
+       interrupt  should  be  async-signal-safe.  Refer signal-safety(7) for a
+       discussion of async-signal-safe functions.
+
+       It is recommended  to  disable  interrupts  using  _clui()  instruction
+       before  executing  any  privileged  code. Doing so would prevent a user
+       interrupt handler from running at a higher privilege level.
+
+
+RETURN VALUE
+       On success,  uintr_register_handler()  returns  0.   On  error,  -1  is
+       returned and errno is set to indicate the cause of the error.
+
+
+ERRORS
+       ENOSYS      Underlying hardware doesn't have support for Uintr.
+
+       EINVAL      flags is not valid.
+
+       EFAULT      handler address is not valid.
+
+       ENOMEM      The system is out of available memory.
+
+       EBUSY       An interrupt handler has already been registered.
+
+
+VERSIONS
+       uintr_register_handler() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_register_handler() is Linux specific.
+
+
+NOTES
+       Currently,  there  is  no  glibc  wrapper for this system call; call it
+       using syscall(2).
+
+       The user interrupt  related  system  calls  need  hardware  support  to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                     uintr_register_handler(2)
diff --git a/tools/uintr/manpages/2_unregister_receiver.txt b/tools/uintr/manpages/2_unregister_receiver.txt
new file mode 100644
index 000000000000..85d4d808e1d2
--- /dev/null
+++ b/tools/uintr/manpages/2_unregister_receiver.txt
@@ -0,0 +1,62 @@
+uintr_unregister_handler(2)   System Calls Manual  uintr_unregister_handler(2)
+
+
+
+NAME
+       uintr_unregister_handler - unregister a user interrupt handler
+
+
+SYNOPSIS
+        int uintr_unregister_handler(unsigned int flags);
+
+
+DESCRIPTION
+       uintr_unregister_handler()  unregisters  a  previously  registered user
+       interrupt handler. If  no  interrupt  handler  was  registered  by  the
+       process uintr_unregister_handler() would return an error.
+
+       Since  interrupt handler is local to a thread, only the thread that has
+       registered      via      uintr_register_handler(2)       can       call
+       uintr_unregister_handler().
+
+       The  interrupt  resources  such  as interrupt vectors and uvec_fd, that
+       have been allocated  for  this  thread,  would  be  deactivated.  Other
+       senders posting interrupts to this thread will not be delivered.
+
+       The  kernel  does  not automatically close the uvec_fds related to this
+       process/thread   when   uintr_unregister_handler()   is   called.   The
+       application  is  expected  to  close  the unused uvec_fds before or the
+       after the handler has been unregistered.
+
+
+RETURN VALUE
+       On success, uintr_unregister_handler() returns  0.   On  error,  -1  is
+       returned and errno is set to indicate the cause of the error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for Uintr.
+
+       EINVAL       flags is not 0.
+
+       EINVAL       No registered user interrupt handler.
+
+
+VERSIONS
+       uintr_unregister_handler() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_unregister_handler() is Linux specific.
+
+
+NOTES
+       Currently,  there  is  no  glibc  wrapper for this system call; call it
+       using syscall(2).
+
+       The user interrupt  related  system  calls  need  hardware  support  to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                   uintr_unregister_handler(2)
diff --git a/tools/uintr/manpages/3_vector_fd.txt b/tools/uintr/manpages/3_vector_fd.txt
new file mode 100644
index 000000000000..98987651ede6
--- /dev/null
+++ b/tools/uintr/manpages/3_vector_fd.txt
@@ -0,0 +1,106 @@
+uintr_vector_fd(2)            System Calls Manual           uintr_vector_fd(2)
+
+
+
+NAME
+       uintr_vector_fd - Create a user interrupt file descriptor - uvec_fd
+
+
+SYNOPSIS
+        int uintr_vector_fd(u64 vector, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_vector_fd()  allocates  a  new  user  interrupt  file  descriptor
+       (uvec_fd) based on the vector registered by the  calling  process.  The
+       uvec_fd can be shared with other processes and the kernel to allow them
+       to generate interrupts with the associated vector.
+
+       The caller must have registered a handler via uintr_register_handler(2)
+       before  attempting to create uvec_fd. The interrupts generated based on
+       this uvec_fd will be delivered only to the  thread  that  created  this
+       file  descriptor.  A  unique  uvec_fd  is  generated  for  each  vector
+       registered using uintr_vector_fd().
+
+       Each thread has a private vector space of 64 vectors ranging from 0-63.
+       Vector number 63 has the highest priority while vector number 0 has the
+       lowest.  If two or more interrupts are pending to be delivered then the
+       interrupt  with  the  higher  vector  number  will  be  delivered first
+       followed by the ones with lower vector numbers. Applications can choose
+       appropriate  vector  numbers  to  prioritize  certain  interrupts  over
+       others.
+
+       Upon interrupt delivery, the handler is invoked with the vector  number
+       pushed  onto  the  stack  to help identify the source of the interrupt.
+       Since the vector space is per-thread, each receiver can receive  up  to
+       64 unique interrupt events.
+
+       A  receiver can choose to share the same uvec_fd with multiple senders.
+       Since an interrupt with the same vector number would be delivered,  the
+       receiver  would  need  to  use  other  mechanisms to identify the exact
+       source of the interrupt.
+
+       The flags argument is reserved for future use.  Currently, it  must  be
+       specified as 0.
+
+       close(2)
+             When the file descriptor is no longer required it should be
+             closed.  When all file descriptors associated with the same
+             uvec_fd object have been closed, the resources for object are
+             freed by the kernel.
+
+       fork(2)
+             A copy of the file descriptor created by uintr_vector_fd() is
+             inherited by the child produced by fork(2).  The duplicate file
+             descriptor is associated with the same uvec_fd object. The
+             close-on-exec flag (FD_CLOEXEC; see fcntl(2)) is set on the
+             file descriptor returned by uintr_vector_fd().
+
+       For  information  on  how  to  generate  interrupts  with uvec_fd refer
+       uintr_register_sender(2).
+
+
+RETURN VALUE
+       On success, uintr_vector_fd() returns a new  uvec_fd  file  descriptor.
+       On  error, -1 is returned and errno is set to indicate the cause of the
+       error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for Uintr.
+
+       EINVAL      flags is not 0.
+
+       EFAULT      handler address is not valid.
+
+       EMFILE        The  per-process  limit  on  the  number  of  open   file
+       descriptors has been reached.
+
+       ENFILE        The  system-wide  limit on the total number of open files
+       has been reached.
+
+       ENODEV       Could not mount (internal) anonymous inode device.
+
+       ENOMEM      The system is out of available memory to allocate uvec_fd.
+
+       ENOSPC      The requested vector is out of available range.
+
+
+VERSIONS
+       uintr_vector_fd() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_vector_fd() is Linux specific.
+
+
+NOTES
+       Currently, there is no glibc wrapper for  this  system  call;  call  it
+       using syscall(2).
+
+       The  user  interrupt  related  system  calls  need  hardware support to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                            uintr_vector_fd(2)
diff --git a/tools/uintr/manpages/4_register_sender.txt b/tools/uintr/manpages/4_register_sender.txt
new file mode 100644
index 000000000000..52e737b07eaa
--- /dev/null
+++ b/tools/uintr/manpages/4_register_sender.txt
@@ -0,0 +1,116 @@
+uintr_register_sender(2)      System Calls Manual     uintr_register_sender(2)
+
+
+
+NAME
+       uintr_register_sender - Register a user inter-process interrupt sender
+
+
+SYNOPSIS
+        int uintr_register_sender(int uvec_fd, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_register_sender() allows a sender process to connect with a Uintr
+       receiver based on the uvec_fd. It returns a user IPI index (uipi_index)
+       that  the  sender  process  can  use  in  conjunction with the SENDUIPI
+       instruction to generate a user IPI.
+
+       When a sender executes 'SENDUIPI  <uipi_index>',  a  user  IPI  can  be
+       delivered by the hardware to the receiver without any intervention from
+       the kernel. Upon IPI delivery, the handler is invoked with  the  vector
+       number, associated with uvec_fd, pushed onto the stack to help identify
+       the source of the interrupt.
+
+       If the receiver for the thread is running the hardware  would  directly
+       deliver the user IPI to the receiver. If the receiver is not running or
+       has disabled receiving  interrupts  using  the  STUI  instruction,  the
+       interrupt  will  be stored in memory and delivered when the receiver is
+       able to receive it.
+
+       If the sender tries to send multiple IPIs while  the  receiver  is  not
+       able  to  receive  them then all the IPIs with the same vector would be
+       coalesced.  Only a single IPI per vector would be delivered.
+
+       uintr_register_sender() can be used to connect with multiple  uvec_fds.
+       uintr_register_sender()  would  return  a  unique  uipi_index  for each
+       uvec_fd the sender connects with.
+
+       In case of a multi-threaded process, the uipi_index is  valid  for  all
+       threads  of  the  same  process.  Other threads do not need to register
+       themselves if they intend to be a user IPI sender.  Executing  SENDUIPI
+       with  a specific uipi_index on different threads would produce the same
+       results based on the connections that have been setup.
+
+       If   a   process    uses    SENDUIPI    without    registering    using
+       uintr_register_sender()  it receives a SIGILL signal. If a process uses
+       an illegal uipi_index, it receives a SIGSEGV signal.  See  sigaction(2)
+       for details of the information available with that signal.
+
+       The  flags  argument is reserved for future use.  Currently, it must be
+       specified as 0.
+
+       close(2)
+             When the file descriptor is no longer required it should be
+             closed.  When all file descriptors associated with the same
+             uvec_fd object have been closed, the resources for object are
+             freed by the kernel. Freeing the uvec_fd object would also
+             result in the associated uipi_index to be freed.
+
+       fork(2)
+             A copy of uvec_fd is inherited by the child produced by
+             fork(2). However the uipi_index would not get inherited by the
+             child. If the child wants to send a user IPI it would have to
+             explicitly register itself using the uintr_register_sender()
+             system call.
+
+       For   information   on   how   to    unregister    a    sender    refer
+       uintr_unregister_sender(2).
+
+
+RETURN VALUE
+       On  success,  uintr_register_sender()  returns  a  new user IPI index -
+       uipi_index. On error, -1 is returned and errno is set to  indicate  the
+       cause of the error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for uintr(7).
+
+       EOPNOTSUPP  uvec_fd does not refer to a Uintr instance.
+
+       EBADF       The uvec_fd passed to the kernel is invalid.
+
+       EINVAL      flags is not 0.
+
+       EISCONN     A connection to this uvec_fd has already been established.
+
+       ECONNRESET  The user interrupt receiver has disabled the connection.
+
+       ESHUTDOWN   The user interrupt receiver has exited the connection.
+
+       ENOSPC        No uipi_index can be allocated. The system has run out of
+       the available user IPI indexes.
+
+       ENOMEM      The system is out of available memory to  register  a  user
+       IPI sender.
+
+
+VERSIONS
+       uintr_register_sender() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_register_sender() is Linux specific.
+
+
+NOTES
+       Currently,  there  is  no  glibc  wrapper for this system call; call it
+       using syscall(2).
+
+       The user interrupt  related  system  calls  need  hardware  support  to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                      uintr_register_sender(2)
diff --git a/tools/uintr/manpages/5_unregister_sender.txt b/tools/uintr/manpages/5_unregister_sender.txt
new file mode 100644
index 000000000000..2ba7bc227956
--- /dev/null
+++ b/tools/uintr/manpages/5_unregister_sender.txt
@@ -0,0 +1,61 @@
+uintr_unregister_sender(2)    System Calls Manual   uintr_unregister_sender(2)
+
+
+
+NAME
+       uintr_unregister_sender  -  Unregister  a  user inter-process interrupt
+       sender
+
+
+SYNOPSIS
+        int uintr_unregister_sender(int ipi_index, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_unregister_sender() unregisters  a  sender  process  based  on  a
+       ipi_index  it had previously received. If no entry is present with this
+       ipi_index the system call return an error.
+
+       The uipi_index that was allocated during uintr_register_sender(2)  will
+       be  freed.  If  a  process  tries to use a uipi_index after it has been
+       freed it would receive a SIGSEGV signal.
+
+       In case of  a  multi-threaded  process  uintr_unregister_sender()  will
+       remove  this connection from all the threads that share the same Target
+       table.
+
+       The flags argument is reserved for future use.  Currently, it  must  be
+       specified as 0.
+
+
+RETURN VALUE
+       On  success,  uintr_unregister_sender()  returns  0.  On  error,  -1 is
+       returned and errno is set to indicate the cause of the error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for uintr(7).
+
+       EINVAL      flags is not 0.
+
+       EINVAL      No connection has been setup for this ipi_index.
+
+
+VERSIONS
+       uintr_unregister_sender() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_unregister_sender() is Linux specific.
+
+
+NOTES
+       Currently, there is no glibc wrapper for  this  system  call;  call  it
+       using syscall(2).
+
+       The  user  interrupt  related  system  calls  need  hardware support to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                    uintr_unregister_sender(2)
diff --git a/tools/uintr/manpages/6_wait.txt b/tools/uintr/manpages/6_wait.txt
new file mode 100644
index 000000000000..a70dc45bc75f
--- /dev/null
+++ b/tools/uintr/manpages/6_wait.txt
@@ -0,0 +1,64 @@
+uintr_wait(2)                 System Calls Manual                uintr_wait(2)
+
+
+
+NAME
+       uintr_wait - wait for user interrupts
+
+
+SYNOPSIS
+        int uintr_wait(u64 usec, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_wait() causes the calling process (or thread) to suspend for usec
+       microseconds until a user interrupt is  delivered.  The  sleep  may  be
+       lengthened  slightly  by  any  system  activity  or  by  the time spent
+       processing the call or by the granularity of system timers.
+
+       uintr_wait() will block in the kernel only when a interrupt handler has
+       been registered using uintr_register_handler(2)
+
+       <uintr_wait()  is an experimental syscall to allow applications to wait
+       specifically for uintr(7).>
+
+
+RETURN VALUE
+       uintr_wait() returns 0 upon successfully suspending  execution  for  at
+       least  usec microseconds. In case of error, -1 is returned and errno is
+       set to indicate the error.
+
+       If it is interrupted by a uintr(7), EINTR is set as the error code.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for Uintr.
+
+       EOPNOTSUPP  No interrupt handler registered.
+
+       EINVAL        flags is not 0.
+
+       EINVAL        usec is greater than 1000000000 (1000 seconds).
+
+       EINTR       A user interrupt was received  and  the  interrupt  handler
+       returned.
+
+
+VERSIONS
+       uintr_wait() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_wait() is Linux specific.
+
+
+NOTES
+       Currently,  there  is  no  glibc  wrapper for this system call; call it
+       using syscall(2).
+
+       The user interrupt  related  system  calls  need  hardware  support  to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                                 uintr_wait(2)
diff --git a/tools/uintr/manpages/7_register_self.txt b/tools/uintr/manpages/7_register_self.txt
new file mode 100644
index 000000000000..8208db0895de
--- /dev/null
+++ b/tools/uintr/manpages/7_register_self.txt
@@ -0,0 +1,75 @@
+uintr_register_self(2)        System Calls Manual       uintr_register_self(2)
+
+
+
+NAME
+       uintr_register_self  - Register a process as a User Interrupt sender to
+       itself.
+
+
+SYNOPSIS
+        int uintr_register_self(u64 vector, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_register_self() allows a process to  connect  with  itself  as  a
+       Uintr  sender  based  on  the  vector.  It  returns  a  user  IPI index
+       (uipi_index) that all threads that are part of the same the process can
+       use  in  conjunction  with  the SENDUIPI instruction to generate a user
+       IPI.
+
+       uintr_register_self() is useful if the  process  would  like  to  avoid
+       using  an  FD  based connection setup for connection between threads of
+       the same  process.  The  behavior  when  a  sender  executes  'SENDUIPI
+       <uipi_index>' is exactly the same as uintr_register_sender(2).
+
+       The  flags  argument is reserved for future use.  Currently, it must be
+       specified as 0.
+
+       For   information   on   how   to    unregister    a    sender    refer
+       uintr_unregister_sender(2).
+
+
+RETURN VALUE
+       On  success,  uintr_register_self()  returns  a  new  user  IPI index -
+       uipi_index. On error, -1 is returned and errno is set to  indicate  the
+       cause of the error.
+
+
+ERRORS
+       ENOSYS      Underlying hardware doesn't have support for uintr(7).
+
+       EINVAL      flags is not 0.
+
+       ECONNRESET  The user interrupt receiver has disabled the connection.
+
+       ESHUTDOWN   The user interrupt receiver has exited the connection.
+
+       ENOSPC        No uipi_index can be allocated. The system has run out of
+                   the available user IPI indexes.
+
+       ENOMEM       The  system  is out of available memory to register a user
+       IPI
+                   sender.
+
+       ENOSPC      The requested vector is out of available range.
+
+
+VERSIONS
+       uintr_register_self() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_register_self() is Linux specific.
+
+
+NOTES
+       Currently, there is no glibc wrapper for  this  system  call;  call  it
+       using syscall(2).
+
+       The  user  interrupt  related  system  calls  need  hardware support to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                        uintr_register_self(2)
diff --git a/tools/uintr/manpages/8_alt_stack.txt b/tools/uintr/manpages/8_alt_stack.txt
new file mode 100644
index 000000000000..eeeca3e8573c
--- /dev/null
+++ b/tools/uintr/manpages/8_alt_stack.txt
@@ -0,0 +1,63 @@
+uintr_alt_stack(2)            System Calls Manual           uintr_alt_stack(2)
+
+
+
+NAME
+       uintr_alt_stack - wait for user interrupts
+
+
+SYNOPSIS
+        int uintr_alt_stack(void  *sp, size_t size, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_alt_stack()  allows  a  thread  to  define  an alternate stack to
+       handle a User Interrupt.
+
+       sp      Base address of the stack
+
+       size      Number of bytes in the stack
+
+       flags      Flags to modify behavior
+
+       The current expectation is for a thread to register an alternate  stack
+       only after it has registered a User Interrupt handler.
+
+       Calling  uintr_alt_stack()  with  a  NULL  base address would clear the
+       alternate stack request.
+
+       uintr_unregister_handler(2)  would  also  clear  any  alternate   stack
+       request that have been made.
+
+
+RETURN VALUE
+       On  success, uintr_alt_stack() returns 0.  On error, -1 is returned and
+       errno is set to indicate the cause of the error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for Uintr.
+
+       EOPNOTSUPP  No interrupt handler registered.
+
+       EINVAL        flags is not 0.
+
+
+VERSIONS
+       uintr_alt_stack() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_alt_stack() is Linux specific.
+
+
+NOTES
+       Currently, there is no glibc wrapper for  this  system  call;  call  it
+       using syscall(2).
+
+       The  user  interrupt  related  system  calls  need  hardware support to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                            uintr_alt_stack(2)
diff --git a/tools/uintr/manpages/9_ipi_fd.txt b/tools/uintr/manpages/9_ipi_fd.txt
new file mode 100644
index 000000000000..6d9698f13d35
--- /dev/null
+++ b/tools/uintr/manpages/9_ipi_fd.txt
@@ -0,0 +1,83 @@
+uintr_ipi_fd(2)               System Calls Manual              uintr_ipi_fd(2)
+
+
+
+NAME
+       uintr_ipi_fd - Register a user inter-process interrupt sender
+
+
+SYNOPSIS
+        int uintr_ipi_fd(unsigned int flags);
+
+
+DESCRIPTION
+       uintr_ipi_fd()  allows  a  sender process to share its Uintr connection
+       with another process. It returns a user IPI FD - uipi_fd that abstracts
+       all the uipi_index based connections.
+
+
+       The  flags  argument is reserved for future use.  Currently, it must be
+       specified as 0.
+
+       close(2)
+             When the file descriptor is no longer required it should be
+             closed.  When all file descriptors associated with the same
+             uipi_fd object have been closed, the resources for object are
+             freed by the kernel. Freeing the uipi_fd object would not
+             result in the associated uipi_indexes to be freed.
+
+       fork(2)
+             A copy of uipi_fd is inherited by the child produced by
+             fork(2). Also all the uipi_indexes would also  get  inherited  by
+       the
+             child.
+
+       ioctl(2)      The following uipi_fd specific command is supported:
+
+            UIPI_SET_TARGET_TABLE            Sets  the  target  table  for the
+       process  with  the  specific            uipi_fd.  Sets   the   hardware
+       registers  to  allow SENDUIPI           execution based on the uipi_fd.
+       <There isn't any option to           clear the hardware registers  once
+       they have been set.>
+
+
+RETURN VALUE
+       On  success,  uintr_ipi_fd()  returns  a  new user IPI fd - uipi_fd. On
+       error, -1 is returned and errno is set to indicate  the  cause  of  the
+       error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for uintr(7).
+
+       EINVAL      flags is not 0.
+
+       EMFILE         The  per-process  limit  on  the  number  of  open  file
+       descriptors has been reached.
+
+       ENFILE       The system-wide limit on the total number  of  open  files
+       has been reached.
+
+       ENODEV       Could not mount (internal) anonymous inode device.
+
+       ENOMEM      The system is out of available memory to allocate uipi_fd.
+
+
+VERSIONS
+       uintr_ipi_fd() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_ipi_fd() is Linux specific.
+
+
+NOTES
+       Currently,  there  is  no  glibc  wrapper for this system call; call it
+       using syscall(2).
+
+       The user interrupt  related  system  calls  need  hardware  support  to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                               uintr_ipi_fd(2)
-- 
2.39.0

