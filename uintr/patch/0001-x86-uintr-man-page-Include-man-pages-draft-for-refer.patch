From d292b8066fb6101c36ab338d5d0a652a05c542ac Mon Sep 17 00:00:00 2001
From: Sohil Mehta <sohil.mehta@intel.com>
Date: Tue, 25 May 2021 16:57:37 -0700
Subject: [PATCH 01/18] x86/uintr/man-page: Include man pages draft for
 reference

draft : 草稿，草案

Included here in plain text format for reference and review.

<Eventually, send the man pages in groff format separately to the
man-pages repository.>

Eventually : 最终
separately : 单独的
repository : 仓库

The formatting for the man pages still needs a little bit of work.

a little bit : 一点点

TODO: The manpages still need to be updated with the latest syscalls.

Signed-off-by: Sohil Mehta <sohil.mehta@intel.com>
---
 tools/uintr/manpages/0_overview.txt           | 290 ++++++++++++++++++
 tools/uintr/manpages/1_register_receiver.txt  | 139 +++++++++
 .../uintr/manpages/2_unregister_receiver.txt  |  62 ++++
 tools/uintr/manpages/3_vector_fd.txt          | 106 +++++++
 tools/uintr/manpages/4_register_sender.txt    | 116 +++++++
 tools/uintr/manpages/5_unregister_sender.txt  |  61 ++++
 tools/uintr/manpages/6_wait.txt               |  64 ++++
 tools/uintr/manpages/7_register_self.txt      |  75 +++++
 tools/uintr/manpages/8_alt_stack.txt          |  63 ++++
 tools/uintr/manpages/9_ipi_fd.txt             |  83 +++++
 10 files changed, 1059 insertions(+)
 create mode 100644 tools/uintr/manpages/0_overview.txt
 create mode 100644 tools/uintr/manpages/1_register_receiver.txt
 create mode 100644 tools/uintr/manpages/2_unregister_receiver.txt
 create mode 100644 tools/uintr/manpages/3_vector_fd.txt
 create mode 100644 tools/uintr/manpages/4_register_sender.txt
 create mode 100644 tools/uintr/manpages/5_unregister_sender.txt
 create mode 100644 tools/uintr/manpages/6_wait.txt
 create mode 100644 tools/uintr/manpages/7_register_self.txt
 create mode 100644 tools/uintr/manpages/8_alt_stack.txt
 create mode 100644 tools/uintr/manpages/9_ipi_fd.txt

diff --git a/tools/uintr/manpages/0_overview.txt b/tools/uintr/manpages/0_overview.txt
new file mode 100644
index 000000000000..28b77fdbbf83
--- /dev/null
+++ b/tools/uintr/manpages/0_overview.txt
@@ -0,0 +1,290 @@
+UINTR(7)               Miscellaneous Information Manual               UINTR(7)
+
+
+
+NAME
+       Uintr - overview of User Interrupts
+
+DESCRIPTION
+       User Interrupts (Uintr) provides a low latency event delivery and inter
+       process communication mechanism. These events can be delivered directly
+       to userspace without a transition to the kernel.
	
	uintr 提供了一个递延迟的event delivery 和进程间通信的机制。这些事件可以在
	不经由kernel的情况下直接delivery到用户态

+
+       In  the  User  Interrupts  hardware  architecture, a receiver is always
+       expected to be a user space task. However, a user interrupt can be sent
+       by  another  user  space  task,  kernel  or  an external source (like a
+       device). The feature that allows another  userspace  task  to  send  an
+       interrupt is referred to as User IPI.
	
	在uintr hardware architecture中, receiver 总是被期望为 userspace task。
	然而，user interrupt 可以被另一个 user space task, kernel 或者
	external source (例如device) 发送。允许另一个userspace task 发送 interrupt 
	的feature 成为 User IPI.

+
+       Uintr  is  a  hardware  dependent,  opt-in  feature. Application aren't
+       expected or able to send or receive  interrupts  unless  they  register
+       themselves with the kernel using the syscall interface described below.
+       It is recommended that applications wanting to use User Interrupts call
+       uintr_register_handler(2) and test whether the call succeeds.
+
	
	Uintr 是一个依赖硬件的，可选择的feature。除非应用程序使用下面描述的syscall 
	interface 向内核注册自己, 否则，它不应该或无法 send/receive interrupts。

+       Hardware  support  for  User  interrupts  may  be  detected using other
+       mechanisms but that could be misleading and is generally not needed:
+        - Using the cpuid instruction (Refer  the  Intel  Software  Developers
+       Manual).
+        -  Checking  for the "uintr" string in /proc/cpuinfo under the "flags"
+       field.

	misleading :误导

	可以使用其他的一些机制来检测 uintr 的硬件支持,但是这可能会产生误导，
	并且通常不需要
	- 使用cpuid instruction (见 SDM)
	- 在 /proc/cpuinfo 中的flags字段，检测 "uintr" string
+
+
+       Applications wanting to use Uintr  should  also  be  able  to  function
+       without  it  as well. Uintr support might be unavailable because of any
+       one of the following reasons:
+        - the kernel code does not contain support
+        - the kernel support has been disabled
+        - the hardware does not support it

	想要使用uintr的应用程序，也应该能够在没有它的情况下运行。Uintr
	support 可能由于下面的一些原因 不被支持:
	- kernel code 没有包含这个支持
	- kernel support 被disabled
	- hardware 不支持
+
+
+   Uintr syscall interface
+       Applications can use and manage Uintr using the system calls  described
+       here.   The  Uintr  system  calls  are  available only if the kernel is
+       configured with the CONFIG_X86_USER_INTERRUPTS option.
	Application 可以通过这里描述的system calls 来使用并且管理 Uintr。Uintr system
	call 只有在kernel 配置了 CONFIG_X86_USER_INTERRUPTS option 的情况下才 available。

+
+       1)  A  user  application   registers   an   interrupt   handler   using
+       uintr_register_handler(2).  The  registered  interrupt  handler will be
+       invoked when a user interrupt is delivered to  that  thread.  Only  one
+       interrupt  handler  can  be  registered by a particular thread within a
+       process.

	1) 用户程序使用 `uintr_register_handler` 来注册 interrupt handler。这个注册的
	interrupt handler 将在 user interrupt delivery 到 该thread时候，被调用。
	进程中的一个特定的线程只能注册一个 interrupt handler。

+
+       2) Each thread that registers a handler has its own unique vector space
+       of 64 vectors. The thread can then use uintr_vector_fd(2) to register a
+       vector and create a user interrupt file descriptor - uvec_fd.
	
	2) 每个thread 可以注册一个handler，该 handler 有自己单独的 64
	vectors中的 vector space。进程可以使用`uintr_vector_fd`来注册一个vector, 并且 
	创建一个 user interrupt fd - uvec_fd.

	NOTE:
	这里 unique 可能是指与众不同的意思。例如，A进程可以注册, 2 3vector, 
	B进程可以注册 4 5 vector, 但是一个thread只能注册一个handler,
	这个handler负责处理该进程注册的所有的vector。
	
+
+       3a) The uvec_fd is only associated with only one Uintr vector.   A  new
+       uvec_fd  must  be  created  for  each  of  the  64  vectors. uvec_fd is
+       automatically inherited by forked processes but the receiver  can  also
+       share  the  uvec_fd with potential senders using any of the existing FD
+       sharing mechanisms (like pidfd_getfd(2) or socket  sendmsg(2)).  Access
+       to uvec_fd allows a sender to generate an interrupt with the associated
+       vector. Upon interrupt delivery, the interrupt handler is invoked  with
+       the  vector  number pushed onto the stack to identify the source of the
+       interrupt.

	uvec_fd 只和一个Uintr vector相关联。必须为 64vectors中的每个vector创建一
	个新的uvec_fd ??? uvec_fd将在 fork 时被自动继承，但是receiver可以通过 任意
	现有的 existing FD sharing mechanism ( pidfd_getfd()/socketsendmeg)向潜在的
	senders共享 uvec_fd. 访问uvec_fd允许sender 生成对应vector的 interrupt,
	interrupt handler 被调用时，将vector number push 到stack上，以用于识别 
	source of the interrupt

+
+       4) Each thread has a local flag called User Interrupt flag  (UIF).  The
+       thread  can set or clear this flag to enable or disable interrupts. The
+       default value of UIF is always 0 (Interrupts disabled). A receiver must
+       execute  the  _stui()  intrinsic  instruction  at some point (before or
+       anytime after registration) to  start  receiving  user  interrupts.  To
+       disable  interrupts  during  critical  sections the thread can call the
+       _clui() instruction to clear UIF.

	intrinsic: 内部的

	每个thread 有一个称为 User Iuterrupt flags 的local flags . 该thread可以设置/
	清空该flags来 enable/disable interrupts。UIF默认值为0(interrupt disabled)。
	receiver 必须在某些时刻(注册前或者注册后的任何时间)执行 _stui() 内部指令来
	开始接收 user interrupts. 当在critical sections thread可以执行_clui()指令
	clear UIF

+
+       5a) For sending a user IPI, the sender task registers with  the  kernel
+       using  uintr_register_sender(2).  The  kernel  would  setup the routing
+       tables to connect the sender and receiver. The syscall returns an index
+       that can be used with the 'SENDUIPI <index>' instruction to send a user
+       IPI.  If the receiver is running, the interrupt is  delivered  directly
+       to  the  receiver  without  any  kernel  intervention.  See  9) for the
+       behavior when the receiver is not running.

	intervention : 介入

	对于sending 一个 user IPI , sender task 通过uintr_register_sender 向 kernel
	注册。kernel 应该初始化 routing table 来连接 sender 和 receiver。syscall
	返回一个index, 来用作 `SENDUIPI <index>` instruction 指令使用来发送 一个 user 
	IPI。如果receiver 是 running的， interrupt 将被直接delivery 到 recevier, 并且没有
	任何kernel的介入. 请见 9) 来了解 当 receiver 不在 running 时的行为。

+
+       5b) If the sender is the kernel or an external source, the uvec_fd  can
+       be  passed  onto the related kernel entity to allow them to connect and
+       generate the user interrupt. The specifics of this mechanism  would  be
+       defined by the kernel entity being connected to.

	entity : 实体

	如果sender 时kernel 或者是 external source, uvec_fd可以被传递到相应的
	kernel entity 来允许他们去connect 和生成 user interrupt。这个机制的 
	specifics 应该由 将要连接的  kernel entity 定义
+
+       6)  If  a  sender task is part of the same process as the receiver then
+       the FD based connection setup can  be  avoided.  uintr_register_self(2)
+       takes  the  vector  as  an  input  and returns an uipi_index similar to
+       uintr_register_sender(2), which can be used by all tasks  of  the  same
+       process to generate User IPIs.
+
	
	如果一个 sender task 和 receiver 是相同的process, 然后 可以避免执行FD 
	base connection setup  流程. `uintr_register_self` 用vector 作为输入，
	并且返回和`uintr_register_sender`相似的 uipi_index, 他可以被 same process 
	的所有的tasks 生成User IPIs。

+       7) If a sender process wants to share it's IPI connections with another
+       process it can request an IPI FD using uintr_ipi_fd(2). Also,  all  IPI
+       connections are inherited upon fork().

	如果一个sender process 想要去share 他的 IPI co 到另一个process, 它可以使用
	`uintr_ipi_fd`请求一个IPI FD。另外，所有的IPI connections，都可以被fork()继承

+
+       8) The sender and receiver are expected to coordinate and then call the
+       teardown syscalls to terminate the connection:
+         a. A sender unregisters with uintr_unregister_sender(2)
+         b. A receiver unregisters with uintr_unregister_handler(2)
+         c. Calling close() on the file descrpiptors if they have been created
+
	coordinate : 协调
	teardown : 拆卸，卸载

	sender 和 receiver 应进行协调, 然后调用 teardown系统调用来终止连接: 
	  a. sender 通过 uintr_unregister_sender 注销
	  b. receiver 通过 uintr_unresiter_handler 注销
	  c. 如果fd被创建，调用 close()  关闭fd

+       If the sender and receiver  aren't  able  to  coordinate,  some  shared
+       kernel  resources  between  them  would  get  freed later when the file
+       descriptors get released automatically on process exit.

	如果 sender 和 receiver 并没有协调好，某些在他们之中的shared kernel  resources 
	将被freed later(在 process exit 是，被自动的释放)

+
+       9) User Interrupts can only be  delivered  if  a  task  is  running  in
+       ring-3.   The  behavior differs when a receiver is not actively running
+       based on each of the below states.
+

	9) Uintr 只能在 task 运行在 ring-3时，被delivery。当receiver不是
	actively running, 行为会根据下面的状态有所不同。

+       a) The receiver has been context switched out because it's  time  slice
+       has  expired  or  a higher priority task is running. The a pending User
+       Interrupt in that case would be delivered when the receiver is  context
+       switched back.

	a) receiver 
	由于时间片过期，或者是更高优先级的task 正在运行, 已经被 context switched out.
	在这种情况下 pending 的user interrupt  将会在 receiver context switched back 
	时候被 delivery

+
+       b)  The  receiver is in context but not running in ring 3 (probably due
+       to a syscall). The interrupt will be delivered the task  enters  ring-3
+       again.
	
	b)  receiver in context 但是，没有 运行在 ring 3（可能由于syscall)。interrupt
	将再次进入ring-3 重新被delivery

+
+       c)  The  receiver is blocked in the kernel and context switched out due
+       to a blocking system call like read() or  sleep().   The  receiver  can
+       choose  to  be  context  switched  in  and  the  blocking syscall to be
+       interrupted with the -EINTR error code similar to signal().  A specific
+       interrupt handler flag needs to be passed to request such behavior.

	c) receiver 在kernel 中 被 blocked, 并且 由于像 read()/sleep()
	登 blocking systemcall 而context switched out。receiver 可以选择
	context switched in 并且让 该blocking syscall 来被 带有-EINTR error
	code 打断，像 signal()一样。

+
+       The  receiver  can  also  block  in  the kernel using the uintr_wait(2)
+       system call if it is explicitly waiting for user interrupts.

	receiver 也可以使用 uintr_wait(2) syscall block 在 kernel, 如果想显示的
	等待 user interrupt

+
+       10)An process can use uintr_alt_stack(2) if  it  wants  to  handle  the
+       interrupt  on  a  different  stack than the one it was running when the
+       interrupt was received.

	10) 如果想要在另一个不同的stack上处理interrupt, 程序可以使用
	`uintr_alt_stack()`, 否则，将在interrupt收到时运行的堆栈上处理。

+
+
+       Multi-threaded applications need to be careful when using  Uintr  since
+       some  of  the features are thread specific. Actions by one thread might
+       not reflect on other threads of the same application.

	多线程的应用程序在使用uintr 时应该谨慎一些, 因为某些feature 是 thread 
	specific。一个线程的一些动作将不会在 same application 的另一个线程中
	reflect(生效)

+
+
+   Toolchain support
+       Support has added to GCC(11.1)  and  Binutils(2.36.1)  to  enable  user
+       interrupt intrinsic instructions and compiler flag (-muintr).

	在GCC(11.1) 和 Binutils(2.36.1) 使能了 userr interrupt intrinsic inst
	和 compiler flag (-muintr)

+
+       The "(interrupt)" attribute can be used to compile a function as a user
+       interrupt handler. In conjunction with the 'muintr' flag, the  compiler
+       would:
+         -  Generate  the  entry  and  exit  sequences  for the User interrupt
+       handler
+         - Handle the saving and restoring of registers
+         - Call uiret to return from a user interrupt handler

	"(intrrupt)" 属性可以用于将function作为user interrupt handler编译。使用了
	'muintr' flag, 编译器应该:
            - 对user interrupt handler 生成 entry/exit sequences
	    - 处理 save/restore regs
	    - 在 uintr handler 返回时调用iret
	
+
+       User   Interrupts   related   compiler   intrinsic    instructions    -
+       <x86gprintrin.h>:

	User interrupts 相关的 compiler intrinsic inst -  <x86gprintrin.h>

+
+       _clui() - Disable user interrupts - clear UIF (User Interrupt Flag).
+
+       _stui() - enable user interrupts - set UIF.
+
+       _testui() - test current value of UIF.
+
+       _uiret() - return from a user interrupt handler.
+
+       _senduipi  <uipi_index>  -  send  a  user  IPI  to  a  target task. The
+       uipi_index is obtained using uintr_register_sender(2).
+
+
+   Interrupt handler restrictions<限制>
+       There are restrictions on what can be done in a user interrupt handler.

	在user interrupt handler 执行会有一些限制.

+
+       For example, the handler and the  functions  called  from  the  handler
+       should only use general purpose registers.

	例如, 在该 handler中调用的其他handler/func 应该只使用通用寄存器。

+
+       For    details    refer   the   Uintr   compiler   programming   guide.
+       https://github.com/intel/uintr-compiler-guide/blob/uintr-
+       gcc-11.1/UINTR-compiler-guide.pdf
+
+
+CONFORMING TO
+              Uintr related system calls are Linux specific.
+
+EXAMPLES
+   Build
+       To compile this sample an updated toolchain is needed.
+        - Use GCC release 11 or higher &
+        - Use Binutils release 2.36 or higher
+
+       gcc -muintr -mgeneral-regs-only -minline-all-stringops uipi_sample.c -lpthread -o uipi_sample
+
+
+   Run
+       $./uipi_sample
+       Receiver enabled interrupts
+       Sending IPI from sender thread
+            -- User Interrupt handler --
+       Success
+
+
+   Program source
+       #define _GNU_SOURCE
+       #include <pthread.h>
+       #include <stdio.h>
+       #include <stdlib.h>
+       #include <syscall.h>
+       #include <unistd.h>
+       #include <x86gprintrin.h>
+
+       #define __NR_uintr_register_handler     471
+       #define __NR_uintr_unregister_handler   472
+       #define __NR_uintr_vector_fd       473
+       #define __NR_uintr_register_sender 474
+       #define __NR_uintr_unregister_sender    475
+
+       #define uintr_register_handler(handler, flags)    syscall(__NR_uintr_register_handler, handler, flags)
+       #define uintr_unregister_handler(flags)      syscall(__NR_uintr_unregister_handler, flags)
+       #define uintr_vector_fd(vector, flags)       syscall(__NR_uintr_vector_fd, vector, flags)
+       #define uintr_register_sender(fd, flags)     syscall(__NR_uintr_register_sender, fd, flags)
+       #define uintr_unregister_sender(ipi_idx, flags)   syscall(__NR_uintr_unregister_sender, ipi_idx, flags)
+
+       unsigned int uintr_received;
+       unsigned int uvec_fd;
+
+       void __attribute__ ((interrupt)) uintr_handler(struct __uintr_frame *ui_frame,
+                                    unsigned long long vector)
+       {
+            static const char print[] = "\t-- User Interrupt handler --\n";
+
+            write(STDOUT_FILENO, print, sizeof(print) - 1);
+            uintr_received = 1;
+       }
+
+       void *sender_thread(void *arg)
+       {
+            int uipi_index;
+
+            uipi_index = uintr_register_sender(uvec_fd, 0);
+            if (uipi_index < 0) {
+                 printf("Sender register error\n");
+                 exit(EXIT_FAILURE);
+            }
+
+            printf("Sending IPI from sender thread\n");
+            _senduipi(uipi_index);
+
+            uintr_unregister_sender(uipi_index, 0);
+
+            return NULL;
+       }
+
+       int main(int argc, char *argv[])
+       {
+            pthread_t pt;
+
+            if (uintr_register_handler(uintr_handler, 0)) {
+                 printf("Interrupt handler register error\n");
+                 exit(EXIT_FAILURE);
+            }
+
+            uvec_fd = uintr_vector_fd(0, 0);
+            if (uvec_fd < 0) {
+                 printf("Interrupt vector registration error\n");
+                 exit(EXIT_FAILURE);
+            }
+
+            _stui();
+            printf("Receiver enabled interrupts\n");
+
+            if (pthread_create(&pt, NULL, &sender_thread, NULL)) {
+                 printf("Error creating sender thread\n");
+                 exit(EXIT_FAILURE);
+            }
+
+            /* Do some other work */
+            while (!uintr_received)
+                 usleep(1);
+
+            pthread_join(pt, NULL);
+            close(uvec_fd);
+            uintr_unregister_handler(0);
+
+            printf("Success\n");
+            exit(EXIT_SUCCESS);
+       }
+
+
+NOTES
+       Currently, there is no glibc wrapper for the Uintr related system call;
+       call  the system calls using syscall(2).

NOTES: 
	现在，没有对于 Uintr 相关syscall glibc wrapper, 调用这些syscall
	使用 syscall()

+
+
+
+                                                                      UINTR(7)
diff --git a/tools/uintr/manpages/1_register_receiver.txt b/tools/uintr/manpages/1_register_receiver.txt
new file mode 100644
index 000000000000..38a80e4d8799
--- /dev/null
+++ b/tools/uintr/manpages/1_register_receiver.txt
@@ -0,0 +1,139 @@
+uintr_register_handler(2)     System Calls Manual    uintr_register_handler(2)
+
+
+
+NAME
+       uintr_register_handler - register a user interrupt handler
+
+
+SYNOPSIS
+        int uintr_register_handler(u64 handler_address, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_register_handler()  registers  a  user  interrupt handler for the
+       calling process. In case of multi-threaded processes the user interrupt
+       handler is only registered for the thread that makes this system call.

	in case of: 如果;一旦;万一
	uintr_register_handler() 对调用进程注册一个uintr handler.如果时
	muti-thread 进程， user interrupt handler 注册用于调用该syscall
	的thread。

+
+       The  handler_address  is  the  function  that would be invoked when the
+       process receives a user interrupt. The function should  be  defined  as
+       below:

	handler_address 是 一个functions的地址，在 进程收到 uintr时，该function被
	调用。该function应该如下定义:

+
+       void __attribute__ ((interrupt)) ui_handler(struct __uintr_frame *frame,
+                                                   unsigned long long vector)
+
+       For  more  details  and  an  example  for  the handler definition refer
+       uintr(7).
+
+       Providing an invalid handler_address could lead to  undefined  behavior
+       for the process.

	提供一个非法的 handler_address 对于进程将会导致 undefined
	behavior

+
+       Each  user  thread can register only one interrupt handler. Each thread
+       that would like to be a receiver must register once.  The  registration
+       is not inherited across forks(2) or when additional threads are created
+       within the same process.
	
	would like to be: 想成为
	每个user thread 只能注册一个 interrupt handler. 想成为receiver的每个thread
	必须要注册一次。该注册不会通过fork()继承，并且在同一个process中创建的其他线程
	同样如此。

+
+       Each thread within a process gets its own interrupt vector space for 64
+       vectors.  The  vector  number  is  pushed  onto  the  stack when a user
+       interrupt is delivered. Since the  vector  space  is  per-thread,  each
+       receiver can receive up to 64 unique interrupt events.

	process 中的每个线程都有自己的 64 vector的interrupt vector space.当 user
	interrupt 被 delivery, 该 vector number 被 push 到 stack。因为vector 
	space 是per-thread, 每个receiver 可以最多接收64 个独立的interrupt events

+
+       For  information  on  creating uvec_fd to register and manage interrupt
+       vectors, refer uintr_vector_fd(2) system call.

	对于creating uvec_fd  注册/管理 interrupt vectors的相关信息，请参考 
	uintr_vector_fd() syscall

+
+       Once an interrupt handler is registered it cannot be changed before the
+       handler   is   unregistered  via  uintr_unregister_handler(2).  Calling
+       uintr_unregister_handler(2)  would  however  invalidate   the   current
+       interrupt resources registered with the kernel.

	一旦 interrupt handler 被注册，在 通过 uintr_unresiter_handler()
	注销之前，都不会被改变。然而，调用 uintr_unregister_handler会让当前注册在 
	kernel 中的 interrupt resources 失效。

+
+       The  interrupt  handler gets invoked only while the process is running.
+       If the process is scheduled out or blocked in  the  kernel,  interrupts
+       will be delivered when the process is scheduled again.

	interrupt handler 将只有在process running 的时候被调用。如果 process 被 
	sched out 或者 在kernel 中 blocked , interrupt 将会在process下一次 sched的
	时候delivery

+
+       An  experimental  mechanism  to  unblock  a  process  as soon as a user
+       interrupt is detected is available for testing.

	一个实验性质的机制可以在检测到一个uintr时，立即unblock process,
	以供测试。

+
+       The following flags may be used to  change  the  blocking  behavior  of
+       uintr_register_handler():

	下面的一些flags可能用于改变 uintr_register_handler()的一些block行为

+
+       UINTR_HANDLER_FLAG_WAITING_ANY      Enable the support for interrupting
+       blocking system calls. Use any of      the below mechanisms  to  enable
+       support.

	使能支持 interrupt blocking syscall.使用如下的机制来 enable support
	(经查看代码，如果传入UINTR_HANDLER_FLAG_WAITING_ANY, 则为
	UINTR_HANDLER_FLAG_WAITING_RECEIVER)
	
+
+       UINTR_HANDLER_FLAG_WAITING_RECEIVER        Enable   the   support   for
+       interrupting blocking system  calls.  The  cost  to       wake  up  the
+       blocking task is paid on the receiver side.

	在receiver 端 承担wake up blocking task的消耗.

+
+       UINTR_HANDLER_FLAG_WAITING_SENDER         Enable    the   support   for
+       interrupting blocking system  calls.  The  cost  to       wake  up  the
+       blocking task is paid on the sender side.

	在sender 端承担 wake up blocking task 的消耗
	
+
+       UINTR_HANDLER_FLAG_WAITING_NONE        Do   not   enable   interrupting
+       blocking system calls. Set by default unless      any of the above have
+       been specified.

	不使能 interrupting blocking system call. 除非制定了上面的值，否则此为默认

+
+
+   Interrupt handler restrictions
+       There are restrictions on what can be done in a user interrupt handler.
+
+       For  example,  the  handler  and  the functions called from the handler
+       should only use general purpose registers.
+
+       For   details   refer   the   Uintr   compiler    programming    guide.
+       https://github.com/intel/uintr-compiler-guide/blob/uintr-
+       gcc-11.1/UINTR-compiler-guide.pdf
+

	(在上面讲到了)

+
+   Security implications
+       A lot of security issues that are applicable to signal  handlers,  also
+       apply to user interrupt handlers.
	
	适用于 signal handler的很多安全问题，同样适用于uintr handler

+
+       The  user  interrupt  handler  by-itself  need  not be re-entrant since
+       interrupts are automatically disabled when the handler is invoked.  But
+       this  isn't  valid if the handler is shared between multiple threads or
+       nested interrupts have been enabled.

	user interrupt handler本身不需要是 可重入的，因为interrupt在 handler被调用
	的时候自动的被disable。但是如果handler在多个线程中被共享或者当nested interrupt
	被使能的时候，那将不再 valid.

+
+       Similar to signal handlers, the functions that are called from  a  user
+       interrupt  should  be  async-signal-safe.  Refer signal-safety(7) for a
+       discussion of async-signal-safe functions.

	和signal handler相似，user interrupt调用的function应该为 async-signal-safe
	对于async-signal-safe function 的讨论请参照 signal-safety.

+
+       It is recommended  to  disable  interrupts  using  _clui()  instruction
+       before  executing  any  privileged  code. Doing so would prevent a user
+       interrupt handler from running at a higher privilege level.

	在执行任何 privileged code 之前, 应该通过 _clui() disable interrupt.
	这样做会阻止 user interrupt handler 以更高的特权级别执行.
	(!!!!这方面的patch还需要再看下)

+
+
+RETURN VALUE
+       On success,  uintr_register_handler()  returns  0.   On  error,  -1  is
+       returned and errno is set to indicate the cause of the error.

RETURN VALUE
	成功时, uintr_register_handler() 返回0. 在error时，返回-1,
	errno被设置为该error的原因

+
+
+ERRORS
+       ENOSYS      Underlying hardware doesn't have support for Uintr.
			(硬件不支持)
+
+       EINVAL      flags is not valid.
+
+       EFAULT      handler address is not valid.
+
+       ENOMEM      The system is out of available memory.
+
+       EBUSY       An interrupt handler has already been registered.
+
+
+VERSIONS
+       uintr_register_handler() first appeared in Linux <tbd>.

	<tbd>: to be determined 待确定

+
+
+CONFORMING TO
+       uintr_register_handler() is Linux specific.
+
+
+NOTES
+       Currently,  there  is  no  glibc  wrapper for this system call; call it
+       using syscall(2).
+
+       The user interrupt  related  system  calls  need  hardware  support  to
+       generate and receive user interrupts. Refer uintr(7) for details.
	
	user interrupt 相关的syscall 需要硬件支持来生成/接收
	uintr。请参照 uintr() 获取细节。
+
+
+
+                                                     uintr_register_handler(2)
diff --git a/tools/uintr/manpages/2_unregister_receiver.txt b/tools/uintr/manpages/2_unregister_receiver.txt
new file mode 100644
index 000000000000..85d4d808e1d2
--- /dev/null
+++ b/tools/uintr/manpages/2_unregister_receiver.txt
@@ -0,0 +1,62 @@
+uintr_unregister_handler(2)   System Calls Manual  uintr_unregister_handler(2)
+
+
+
+NAME
+       uintr_unregister_handler - unregister a user interrupt handler
+
+
+SYNOPSIS
+        int uintr_unregister_handler(unsigned int flags);
+
+
+DESCRIPTION
+       uintr_unregister_handler()  unregisters  a  previously  registered user
+       interrupt handler. If  no  interrupt  handler  was  registered  by  the
+       process uintr_unregister_handler() would return an error.

	uintr_unregister_handler()注销之前已经注册过的 uintr handler.如果之前进程
	没有注册 interrupt handler, uintr_unregister_handler()将会返回错误

+
+       Since  interrupt handler is local to a thread, only the thread that has
+       registered      via      uintr_register_handler(2)       can       call
+       uintr_unregister_handler().

	因为 interrupt handler 是local to thread的，只有通过 uintr_register_handler
	注册的thread 可以调用 uintr_unregister_handler()

+
+       The  interrupt  resources  such  as interrupt vectors and uvec_fd, that
+       have been allocated  for  this  thread,  would  be  deactivated.  Other
+       senders posting interrupts to this thread will not be delivered.

	例如 interrupt vectors 和 uvec_fd 这样的已经被 该进程分配的interrupt 
	resources , 将会被 deactivated. 其他senders 递送到 该进程的的 interrupt 
	也不会delivery

+
+       The  kernel  does  not automatically close the uvec_fds related to this
+       process/thread   when   uintr_unregister_handler()   is   called.   The
+       application  is  expected  to  close  the unused uvec_fds before or the
+       after the handler has been unregistered.

	kernel 将不会自动close 该process/thread 相关的uvec_fds, 当
	uintr_unregister_handler()被调用的时候。期望apps在unregister
	handler前后 关闭 不用的 uvec_fds

+
+
+RETURN VALUE
+       On success, uintr_unregister_handler() returns  0.   On  error,  -1  is
+       returned and errno is set to indicate the cause of the error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for Uintr.
+
+       EINVAL       flags is not 0.
+
+       EINVAL       No registered user interrupt handler.
+
+
+VERSIONS
+       uintr_unregister_handler() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_unregister_handler() is Linux specific.
+
+
+NOTES
+       Currently,  there  is  no  glibc  wrapper for this system call; call it
+       using syscall(2).
+
+       The user interrupt  related  system  calls  need  hardware  support  to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                   uintr_unregister_handler(2)
diff --git a/tools/uintr/manpages/3_vector_fd.txt b/tools/uintr/manpages/3_vector_fd.txt
new file mode 100644
index 000000000000..98987651ede6
--- /dev/null
+++ b/tools/uintr/manpages/3_vector_fd.txt
@@ -0,0 +1,106 @@
+uintr_vector_fd(2)            System Calls Manual           uintr_vector_fd(2)
+
+
+
+NAME
+       uintr_vector_fd - Create a user interrupt file descriptor - uvec_fd
+
+
+SYNOPSIS
+        int uintr_vector_fd(u64 vector, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_vector_fd()  allocates  a  new  user  interrupt  file  descriptor
+       (uvec_fd) based on the vector registered by the  calling  process.  The
+       uvec_fd can be shared with other processes and the kernel to allow them
+       to generate interrupts with the associated vector.

	uintr_vector_fd() 分配一个新的 uintr fd(uvec_fd)基于调用进程注册的vector.
	uvec_fd 可以在kernel 中的其他进程中共享，用来允许他们产生相关 vector的
	interrupt.

+
+       The caller must have registered a handler via uintr_register_handler(2)
+       before  attempting to create uvec_fd. The interrupts generated based on
+       this uvec_fd will be delivered only to the  thread  that  created  this
+       file  descriptor.  A  unique  uvec_fd  is  generated  for  each  vector
+       registered using uintr_vector_fd().

	caller 在尝试创建 uvec_fd 之前， 必须通过uintr_register_handler()注册 
	一个handler。基于改 uvec_fd生成的interrupt 只会delivery到创建该fd的
	thread。对于每一个通过uintr_vector_fd()注册的vector，都会生成独立的
	uvec_fd.

+
+       Each thread has a private vector space of 64 vectors ranging from 0-63.
+       Vector number 63 has the highest priority while vector number 0 has the
+       lowest.  If two or more interrupts are pending to be delivered then the
+       interrupt  with  the  higher  vector  number  will  be  delivered first
+       followed by the ones with lower vector numbers. Applications can choose
+       appropriate  vector  numbers  to  prioritize  certain  interrupts  over
+       others.

	每个进程有 一个独立的64 vectors的 vector space, 范围时0~63.
	64是最高的优先级,而0时最低的。如果两个或者多个中断同时等待被delivery.
	将会首先delivery higher vector number 的intr。应用程序可以选择合适的
	vector number,用来使某些中断有效级高于其他的中断

+
+       Upon interrupt delivery, the handler is invoked with the vector  number
+       pushed  onto  the  stack  to help identify the source of the interrupt.
+       Since the vector space is per-thread, each receiver can receive  up  to
+       64 unique interrupt events.

	随着 interrupt delivery，handler 被调用，并且 vector number 被 push到 
	stack，来帮助识别中断源。因为 vector space 是per-thread，每个receiver
	可以收到64 个独立的interrupt events

+
+       A  receiver can choose to share the same uvec_fd with multiple senders.
+       Since an interrupt with the same vector number would be delivered,  the
+       receiver  would  need  to  use  other  mechanisms to identify the exact
+       source of the interrupt.

	receiver可以选择来和多个sender分享同一个uvec_fd.因为带有相同vector
	number 的interrupt可能会被delivery, 所以receiver应该需要用其他的机制来识别
	确切的中断源。

+
+       The flags argument is reserved for future use.  Currently, it  must  be
+       specified as 0.

	flags 参数被保留用于未来用途。现在，它必须指定为0。

+
+       close(2)
+             When the file descriptor is no longer required it should be
+             closed.  When all file descriptors associated with the same
+             uvec_fd object have been closed, the resources for object are
+             freed by the kernel.

	close(2)
		当fd不再需要，他应该被closed。当所有相关同一个uvec_fd
		object的 file descriptors被关闭时，该object的resources才会被
		kernel释放

+
+       fork(2)
+             A copy of the file descriptor created by uintr_vector_fd() is
+             inherited by the child produced by fork(2).  The duplicate file
+             descriptor is associated with the same uvec_fd object. The
+             close-on-exec flag (FD_CLOEXEC; see fcntl(2)) is set on the
+             file descriptor returned by uintr_vector_fd().

	fork(2)
		用uintr_vector_fd创建的file descriptor 的副本(copy)可以通过
		fork产生的子程序继承获得。duplicate fd 将会和同一个uvec_fd 
		object 相关。 FD_CLOEXEC flag 将会设置在通过 uintr_vector_fd 
		返回的fd上.
+
+       For  information  on  how  to  generate  interrupts  with uvec_fd refer
+       uintr_register_sender(2).
+
+
+RETURN VALUE
+       On success, uintr_vector_fd() returns a new  uvec_fd  file  descriptor.
+       On  error, -1 is returned and errno is set to indicate the cause of the
+       error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for Uintr.
+
+       EINVAL      flags is not 0.
+
+       EFAULT      handler address is not valid.
+
+       EMFILE        The  per-process  limit  on  the  number  of  open   file
+       descriptors has been reached.
+
+       ENFILE        The  system-wide  limit on the total number of open files
+       has been reached.
+
+       ENODEV       Could not mount (internal) anonymous inode device.
+
+       ENOMEM      The system is out of available memory to allocate uvec_fd.
+
+       ENOSPC      The requested vector is out of available range.
+
+
+VERSIONS
+       uintr_vector_fd() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_vector_fd() is Linux specific.
+
+
+NOTES
+       Currently, there is no glibc wrapper for  this  system  call;  call  it
+       using syscall(2).
+
+       The  user  interrupt  related  system  calls  need  hardware support to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                            uintr_vector_fd(2)
diff --git a/tools/uintr/manpages/4_register_sender.txt b/tools/uintr/manpages/4_register_sender.txt
new file mode 100644
index 000000000000..52e737b07eaa
--- /dev/null
+++ b/tools/uintr/manpages/4_register_sender.txt
@@ -0,0 +1,116 @@
+uintr_register_sender(2)      System Calls Manual     uintr_register_sender(2)
+
+
+
+NAME
+       uintr_register_sender - Register a user inter-process interrupt sender
+
+
+SYNOPSIS
+        int uintr_register_sender(int uvec_fd, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_register_sender() allows a sender process to connect with a Uintr
+       receiver based on the uvec_fd. It returns a user IPI index (uipi_index)
+       that  the  sender  process  can  use  in  conjunction with the SENDUIPI
+       instruction to generate a user IPI.

	conjunction with: 结合

	uintr_register_sender() 允许一个sender process 连接到一个 基于uvec_fd的
	uintr receiver上。它将返回一个user IPI index(uipi_index)，
	sender process 可以结合他和 SENDUIPI指令，来生成一个 user IPI.

+
+       When a sender executes 'SENDUIPI  <uipi_index>',  a  user  IPI  can  be
+       delivered by the hardware to the receiver without any intervention from
+       the kernel. Upon IPI delivery, the handler is invoked with  the  vector
+       number, associated with uvec_fd, pushed onto the stack to help identify
+       the source of the interrupt.

	intervention : 介入

	当sender 执行 'SENDUIPI <uipi_index>', user IPI将通过硬件delivery到 receiver
	在没有kernel任何介入的情况下。在IPI delivery后，handler 被引入，带者一个vector 
	number ,该值和 uvec_fd相关，将pushed 到 stack 上来帮助识别中断源

+
+       If the receiver for the thread is running the hardware  would  directly
+       deliver the user IPI to the receiver. If the receiver is not running or
+       has disabled receiving  interrupts  using  the  STUI  instruction,  the
+       interrupt  will  be stored in memory and delivered when the receiver is
+       able to receive it.

	如果receiver对应的thread正在 hardware上运行，将会向receiver直接deliver
	user IPI 。如果 receiver 没有运行或者使用了STUI inst disable 接收中断，
	中断将会保存在 memory中，并且在receiver 可以接收他的时候delivery

+
+       If the sender tries to send multiple IPIs while  the  receiver  is  not
+       able  to  receive  them then all the IPIs with the same vector would be
+       coalesced.  Only a single IPI per vector would be delivered.

	coalesce: 合并 

	如果当sender在receiver 不能接收中断时，尝试发送多个IPI, 带有相同vector的所有ipi
	将会被合并。每个vector只有一个IPI将会被deliver

+
+       uintr_register_sender() can be used to connect with multiple  uvec_fds.
+       uintr_register_sender()  would  return  a  unique  uipi_index  for each
+       uvec_fd the sender connects with.

	uintr_register_sender() 可以被用来连接 multiple uvec_fds ???
	uintr_register_sender()将会对每个 sender 连接的每个uvec_fd
	返回独立的uipi_index.

+
+       In case of a multi-threaded process, the uipi_index is  valid  for  all
+       threads  of  the  same  process.  Other threads do not need to register
+       themselves if they intend to be a user IPI sender.  Executing  SENDUIPI
+       with  a specific uipi_index on different threads would produce the same
+       results based on the connections that have been setup.

	如果是多线程，uipi_index将会对同一进程中的所有threads生效。如果其他线程
	打算成为 user IPI sender 江湖需要再注册他们。在不通的thread上执行
	带有特定的uipi_index 的SENDUIPI, 将会根据已设置的connections产生相同结果。

+
+       If   a   process    uses    SENDUIPI    without    registering    using
+       uintr_register_sender()  it receives a SIGILL signal. If a process uses
+       an illegal uipi_index, it receives a SIGSEGV signal.  See  sigaction(2)
+       for details of the information available with that signal.

	如果一个进程使用SENDUIPI指令, 但是在没有使用uintr_register_sender()
	的情况下，他将会收到SIGILL信号。如果一个进程使用了非法的uipi_index, 他将
	收到SIGSEGV信号。请查看 sigaction了解关于该信号的可获得的信息(???)。

+
+       The  flags  argument is reserved for future use.  Currently, it must be
+       specified as 0.

	flags参数被保留，以供未来使用。现在，他必须指定为0。

+
+       close(2)
+             When the file descriptor is no longer required it should be
+             closed.  When all file descriptors associated with the same
+             uvec_fd object have been closed, the resources for object are
+             freed by the kernel. Freeing the uvec_fd object would also
+             result in the associated uipi_index to be freed.

		（上面有讲)
+
+       fork(2)
+             A copy of uvec_fd is inherited by the child produced by
+             fork(2). However the uipi_index would not get inherited by the
+             child. If the child wants to send a user IPI it would have to
+             explicitly register itself using the uintr_register_sender()
+             system call.
		(上面有讲)
+
+       For   information   on   how   to    unregister    a    sender    refer
+       uintr_unregister_sender(2).
+
+
+RETURN VALUE
+       On  success,  uintr_register_sender()  returns  a  new user IPI index -
+       uipi_index. On error, -1 is returned and errno is set to  indicate  the
+       cause of the error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for uintr(7).
+
+       EOPNOTSUPP  uvec_fd does not refer to a Uintr instance.
+
+       EBADF       The uvec_fd passed to the kernel is invalid.
+
+       EINVAL      flags is not 0.
+
+       EISCONN     A connection to this uvec_fd has already been established.
+
+       ECONNRESET  The user interrupt receiver has disabled the connection.
+
+       ESHUTDOWN   The user interrupt receiver has exited the connection.
+
+       ENOSPC        No uipi_index can be allocated. The system has run out of
+       the available user IPI indexes.
+
+       ENOMEM      The system is out of available memory to  register  a  user
+       IPI sender.
+
+
+VERSIONS
+       uintr_register_sender() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_register_sender() is Linux specific.
+
+
+NOTES
+       Currently,  there  is  no  glibc  wrapper for this system call; call it
+       using syscall(2).
+
+       The user interrupt  related  system  calls  need  hardware  support  to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                      uintr_register_sender(2)
diff --git a/tools/uintr/manpages/5_unregister_sender.txt b/tools/uintr/manpages/5_unregister_sender.txt
new file mode 100644
index 000000000000..2ba7bc227956
--- /dev/null
+++ b/tools/uintr/manpages/5_unregister_sender.txt
@@ -0,0 +1,61 @@
+uintr_unregister_sender(2)    System Calls Manual   uintr_unregister_sender(2)
+
+
+
+NAME
+       uintr_unregister_sender  -  Unregister  a  user inter-process interrupt
+       sender
+
+
+SYNOPSIS
+        int uintr_unregister_sender(int ipi_index, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_unregister_sender() unregisters  a  sender  process  based  on  a
+       ipi_index  it had previously received. If no entry is present with this
+       ipi_index the system call return an error.
+
+       The uipi_index that was allocated during uintr_register_sender(2)  will
+       be  freed.  If  a  process  tries to use a uipi_index after it has been
+       freed it would receive a SIGSEGV signal.
+
+       In case of  a  multi-threaded  process  uintr_unregister_sender()  will
+       remove  this connection from all the threads that share the same Target
+       table.
+
+       The flags argument is reserved for future use.  Currently, it  must  be
+       specified as 0.

	(内容和 uintr_unregister_handler差不多)
+
+
+RETURN VALUE
+       On  success,  uintr_unregister_sender()  returns  0.  On  error,  -1 is
+       returned and errno is set to indicate the cause of the error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for uintr(7).
+
+       EINVAL      flags is not 0.
+
+       EINVAL      No connection has been setup for this ipi_index.
+
+
+VERSIONS
+       uintr_unregister_sender() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_unregister_sender() is Linux specific.
+
+
+NOTES
+       Currently, there is no glibc wrapper for  this  system  call;  call  it
+       using syscall(2).
+
+       The  user  interrupt  related  system  calls  need  hardware support to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                    uintr_unregister_sender(2)
diff --git a/tools/uintr/manpages/6_wait.txt b/tools/uintr/manpages/6_wait.txt
new file mode 100644
index 000000000000..a70dc45bc75f
--- /dev/null
+++ b/tools/uintr/manpages/6_wait.txt
@@ -0,0 +1,64 @@
+uintr_wait(2)                 System Calls Manual                uintr_wait(2)
+
+
+
+NAME
+       uintr_wait - wait for user interrupts
+
+
+SYNOPSIS
+        int uintr_wait(u64 usec, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_wait() causes the calling process (or thread) to suspend for usec
+       microseconds until a user interrupt is  delivered.  The  sleep  may  be
+       lengthened  slightly  by  any  system  activity  or  by  the time spent
+       processing the call or by the granularity of system timers.

	lengthen : 变长
	activity : 活动; 活力
	granularity: 粒度

	uintr_wait() 导致 calling process (or thread) 暂停 <usec> microseconds
	直到 user interrupt 被delivery。任何系统活动 或者 处理call
	消耗的时间，或者system timer 的粒度都可以略微的延长睡眠时间。

+
+       uintr_wait() will block in the kernel only when a interrupt handler has
+       been registered using uintr_register_handler(2)

	只有当一个 使用 uintr_register_handler 注册了interrupt handler的情况下，
	uintr_wait()将会blocked在 kernel ,

+
+       <uintr_wait()  is an experimental syscall to allow applications to wait
+       specifically for uintr(7).>

	experimental : 实验性质的，用于实验的
	specifically : 确切的，明确的

	<uintr_wait()是一个实验性质的 syscall , 允许applications 主动等待 uintr>

+
+
+RETURN VALUE
+       uintr_wait() returns 0 upon successfully suspending  execution  for  at
+       least  usec microseconds. In case of error, -1 is returned and errno is
+       set to indicate the error.

	uintr_wail() 在成功暂停至少 usec ms 后返回0。

	NOTE: 如果收到了在usec时间内收到interrupt, 则返回EINTR
	```
	================tools/testing/selftests/x86/uintr.c================
	ret = uintr_wait(1000000, 0);

	if (ret && (errno == EINTR) && uintr_received)
	        printf("[OK]\tUser interrupt received\n");
	else
	        printf("[FAIL]\tUser interrupt not received during syscall\n");

	```
+
+       If it is interrupted by a uintr(7), EINTR is set as the error code.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for Uintr.
+
+       EOPNOTSUPP  No interrupt handler registered.
+
+       EINVAL        flags is not 0.
+
+       EINVAL        usec is greater than 1000000000 (1000 seconds).
+
+       EINTR       A user interrupt was received  and  the  interrupt  handler
+       returned.
+
+
+VERSIONS
+       uintr_wait() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_wait() is Linux specific.
+
+
+NOTES
+       Currently,  there  is  no  glibc  wrapper for this system call; call it
+       using syscall(2).
+
+       The user interrupt  related  system  calls  need  hardware  support  to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                                 uintr_wait(2)
diff --git a/tools/uintr/manpages/7_register_self.txt b/tools/uintr/manpages/7_register_self.txt
new file mode 100644
index 000000000000..8208db0895de
--- /dev/null
+++ b/tools/uintr/manpages/7_register_self.txt
@@ -0,0 +1,75 @@
+uintr_register_self(2)        System Calls Manual       uintr_register_self(2)
+
+
+
+NAME
+       uintr_register_self  - Register a process as a User Interrupt sender to
+       itself.
+
+
+SYNOPSIS
+        int uintr_register_self(u64 vector, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_register_self() allows a process to  connect  with  itself  as  a
+       Uintr  sender  based  on  the  vector.  It  returns  a  user  IPI index
+       (uipi_index) that all threads that are part of the same the process can
+       use  in  conjunction  with  the SENDUIPI instruction to generate a user
+       IPI.

	uintr_register_self()允许进程作为 基于 vector的uintr sender connect 自己。
	它将返回一个 user IPI index(uipi_index) , 相同进程的其他线程可以通过结合
	SENDUIPI指令生成user IPI

+
+       uintr_register_self() is useful if the  process  would  like  to  avoid
+       using  an  FD  based connection setup for connection between threads of
+       the same  process.  The  behavior  when  a  sender  executes  'SENDUIPI
+       <uipi_index>' is exactly the same as uintr_register_sender(2).

	be exactly the same as : 一模一样

	假如进程想要避免使用在相同进程的线程中基于FD 初始化连接的方式, 
	uintr_register_self()是有用的。 当sender执行 'SENDUIPI <uipi_index>'
	将和uintr_register_sender一模一样

+
+       The  flags  argument is reserved for future use.  Currently, it must be
+       specified as 0.
+
+       For   information   on   how   to    unregister    a    sender    refer
+       uintr_unregister_sender(2).
+
+
+RETURN VALUE
+       On  success,  uintr_register_self()  returns  a  new  user  IPI index -
+       uipi_index. On error, -1 is returned and errno is set to  indicate  the
+       cause of the error.
+
+
+ERRORS
+       ENOSYS      Underlying hardware doesn't have support for uintr(7).
+
+       EINVAL      flags is not 0.
+
+       ECONNRESET  The user interrupt receiver has disabled the connection.
+
+       ESHUTDOWN   The user interrupt receiver has exited the connection.
+
+       ENOSPC        No uipi_index can be allocated. The system has run out of
+                   the available user IPI indexes.
+
+       ENOMEM       The  system  is out of available memory to register a user
+       IPI
+                   sender.
+
+       ENOSPC      The requested vector is out of available range.
+
+
+VERSIONS
+       uintr_register_self() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_register_self() is Linux specific.
+
+
+NOTES
+       Currently, there is no glibc wrapper for  this  system  call;  call  it
+       using syscall(2).
+
+       The  user  interrupt  related  system  calls  need  hardware support to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                        uintr_register_self(2)
diff --git a/tools/uintr/manpages/8_alt_stack.txt b/tools/uintr/manpages/8_alt_stack.txt
new file mode 100644
index 000000000000..eeeca3e8573c
--- /dev/null
+++ b/tools/uintr/manpages/8_alt_stack.txt
@@ -0,0 +1,63 @@
+uintr_alt_stack(2)            System Calls Manual           uintr_alt_stack(2)
+
+
+
+NAME
+       uintr_alt_stack - wait for user interrupts    
	(!!!这里有问题)
+
+
+SYNOPSIS
+        int uintr_alt_stack(void  *sp, size_t size, unsigned int flags);
+
+
+DESCRIPTION
+       uintr_alt_stack()  allows  a  thread  to  define  an alternate stack to
+       handle a User Interrupt.

	uintr_alt_stack() 允许thread 定义一个 alternate stack来处理 User
	Interrupt

+
+       sp      Base address of the stack
+
+       size      Number of bytes in the stack
+
+       flags      Flags to modify behavior
+
+       The current expectation is for a thread to register an alternate  stack
+       only after it has registered a User Interrupt handler.
+
+       Calling  uintr_alt_stack()  with  a  NULL  base address would clear the
+       alternate stack request.
+
+       uintr_unregister_handler(2)  would  also  clear  any  alternate   stack
+       request that have been made.
+
+
+RETURN VALUE
+       On  success, uintr_alt_stack() returns 0.  On error, -1 is returned and
+       errno is set to indicate the cause of the error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for Uintr.
+
+       EOPNOTSUPP  No interrupt handler registered.
+
+       EINVAL        flags is not 0.
+
+
+VERSIONS
+       uintr_alt_stack() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_alt_stack() is Linux specific.
+
+
+NOTES
+       Currently, there is no glibc wrapper for  this  system  call;  call  it
+       using syscall(2).
+
+       The  user  interrupt  related  system  calls  need  hardware support to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                            uintr_alt_stack(2)
diff --git a/tools/uintr/manpages/9_ipi_fd.txt b/tools/uintr/manpages/9_ipi_fd.txt
new file mode 100644
index 000000000000..6d9698f13d35
--- /dev/null
+++ b/tools/uintr/manpages/9_ipi_fd.txt
@@ -0,0 +1,83 @@
+uintr_ipi_fd(2)               System Calls Manual              uintr_ipi_fd(2)
+
+
+
+NAME
+       uintr_ipi_fd - Register a user inter-process interrupt sender
+
+
+SYNOPSIS
+        int uintr_ipi_fd(unsigned int flags);
+
+
+DESCRIPTION
+       uintr_ipi_fd()  allows  a  sender process to share its Uintr connection
+       with another process. It returns a user IPI FD - uipi_fd that abstracts
+       all the uipi_index based connections.
+
+
+       The  flags  argument is reserved for future use.  Currently, it must be
+       specified as 0.
+
+       close(2)
+             When the file descriptor is no longer required it should be
+             closed.  When all file descriptors associated with the same
+             uipi_fd object have been closed, the resources for object are
+             freed by the kernel. Freeing the uipi_fd object would not
+             result in the associated uipi_indexes to be freed.
+
+       fork(2)
+             A copy of uipi_fd is inherited by the child produced by
+             fork(2). Also all the uipi_indexes would also  get  inherited  by
+       the
+             child.
+
+       ioctl(2)      The following uipi_fd specific command is supported:
+
+            UIPI_SET_TARGET_TABLE            Sets  the  target  table  for the
+       process  with  the  specific            uipi_fd.  Sets   the   hardware
+       registers  to  allow SENDUIPI           execution based on the uipi_fd.
+       <There isn't any option to           clear the hardware registers  once
+       they have been set.>
+
+
+RETURN VALUE
+       On  success,  uintr_ipi_fd()  returns  a  new user IPI fd - uipi_fd. On
+       error, -1 is returned and errno is set to indicate  the  cause  of  the
+       error.
+
+
+ERRORS
+       ENOSYS  Underlying hardware doesn't have support for uintr(7).
+
+       EINVAL      flags is not 0.
+
+       EMFILE         The  per-process  limit  on  the  number  of  open  file
+       descriptors has been reached.
+
+       ENFILE       The system-wide limit on the total number  of  open  files
+       has been reached.
+
+       ENODEV       Could not mount (internal) anonymous inode device.
+
+       ENOMEM      The system is out of available memory to allocate uipi_fd.
+
+
+VERSIONS
+       uintr_ipi_fd() first appeared in Linux <tbd>.
+
+
+CONFORMING TO
+       uintr_ipi_fd() is Linux specific.
+
+
+NOTES
+       Currently,  there  is  no  glibc  wrapper for this system call; call it
+       using syscall(2).
+
+       The user interrupt  related  system  calls  need  hardware  support  to
+       generate and receive user interrupts. Refer uintr(7) for details.
+
+
+
+                                                               uintr_ipi_fd(2)
-- 
2.39.0

